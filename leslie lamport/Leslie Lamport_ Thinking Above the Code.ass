[Script Info]
Collisions: Normal
PlayResX: 384
PlayResY: 288
ScaledBorderAndShadow: no
ScriptType: v4.00+
Synch Point: 1

[Custom Info]
OriginalTextStyle: 原文字幕
TranslationTextStyle: 译文字幕

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,方正黑体_GBK,21,&H00FFFFFF,&HF0000000,&H006C3300,&H00000000,-1,0,0,0,100,100,0,0.00,1,2,1,2,5,5,15,1
Style: 译文字幕,方正黑体_GBK,21,&H00FFFFFF,&HF0000000,&H006C3300,&H00000000,-1,0,0,0,100,100,0,0.00,1,2,1,2,5,5,15,1
Style: 原文字幕,方正综艺_GBK,14,&H00FFFFFF,&HF0000000,&H002F2F2F,&H00000000,-1,0,0,0,100,100,0,0.00,1,2,1,2,5,5,15,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.25,0:00:02.90,译文字幕,,0,0,0,,朋友们\N{\r原文字幕}ladies and gentlemen
Dialogue: 0,0:00:02.76,0:00:05.30,译文字幕,,0,0,0,,掌声有请Mr.JB\N{\r原文字幕}please welcome judith bishop
Dialogue: 0,0:00:13.49,0:00:15.35,译文字幕,,0,0,0,,下午好\N{\r原文字幕}good afternoon everybody
Dialogue: 0,0:00:15.80,0:00:20.27,译文字幕,,0,0,0,,继续开会\N{\r原文字幕}welcome back to the plenary session of the Microsoft faculty summit
Dialogue: 0,0:00:20.21,0:00:23.54,译文字幕,,0,0,0,,有请leslie lamport\N{\r原文字幕}it's my great pleasure to introduce to you today
Dialogue: 0,0:00:23.34,0:00:29.84,译文字幕,,0,0,0,,lamport 现在是微软的（2013）\N{\r原文字幕}Leslie Lamport who's a principal researcher at our Microsoft Research Silicon Valley Lab
Dialogue: 0,0:00:30.71,0:00:36.02,译文字幕,,0,0,0,,咱们这些教员和学生\N{\r原文字幕}so students and faculty who have taught operating systems courses
Dialogue: 0,0:00:36.09,0:00:39.47,译文字幕,,0,0,0,,从事计算机相关的这些人\N{\r原文字幕}as well as anybody who's really used a computer
Dialogue: 0,0:00:39.50,0:00:42.86,译文字幕,,0,0,0,,都从lamport的工作中获益良多\N{\r原文字幕}will have benefited from Leslie's work
Dialogue: 0,0:00:42.60,0:00:47.42,译文字幕,,0,0,0,,你就比如 逻辑时钟、安全与活性、序列化一致性（paxos）\N{\r原文字幕}on logical clocks 、safety and liveness 、sequential consistency
Dialogue: 0,0:00:47.34,0:00:50.93,译文字幕,,0,0,0,,还有老多了\N{\r原文字幕}and many other parts of operating systems
Dialogue: 0,0:00:50.85,0:00:57.92,译文字幕,,0,0,0,,这些在某方面奠定了计算机世界的理论\N{\r原文字幕}which laid the basis for the safe operation of the computers that we have today
Dialogue: 0,0:00:57.63,0:01:05.00,译文字幕,,0,0,0,,在个人电脑OR大型分布式集群中发挥着作用\N{\r原文字幕}as they moved from the single desktop to the large number of interconnected devices we have
Dialogue: 0,0:01:06.11,0:01:13.58,译文字幕,,0,0,0,,来微软前\N{\r原文字幕}Leslie before he joined Microsoft was a member of certain various prestigious institutions
Dialogue: 0,0:01:13.98,0:01:22.79,译文字幕,,0,0,0,,leslie的履历就很传奇了\N{\r原文字幕}he was at MIT 、at Brandis University and at companies such as Dec 、Compaq and SR I
Dialogue: 0,0:01:23.96,0:01:30.29,译文字幕,,0,0,0,,职业生涯中已经取得了各种荣誉和证明\N{\r原文字幕}in his career he has also received several honorary doctorates
Dialogue: 0,0:01:30.39,0:01:38.57,译文字幕,,0,0,0,,但仍致力于帮助科学家发掘工作之美\N{\r原文字幕}and he has tried very hard to help scientists see their works’s beautiful
Dialogue: 0,0:01:38.82,0:01:42.02,译文字幕,,0,0,0,,为此，他创造了一些东西\N{\r原文字幕}and for that purpose he also developed something
Dialogue: 0,0:01:41.94,0:01:44.81,译文字幕,,0,0,0,,比如 LaTeX\N{\r原文字幕}that I think you all know very well which is let ik
Dialogue: 0,0:01:45.35,0:01:50.09,译文字幕,,0,0,0,,他现在致力于帮助我们\N{\r原文字幕}he's now going to go on and try and persuade engineers
Dialogue: 0,0:01:50.34,0:01:53.57,译文字幕,,0,0,0,,发现另一些真香的东西\N{\r原文字幕}that there's something else that is beautiful in life
Dialogue: 0,0:01:53.10,0:01:54.98,译文字幕,,0,0,0,,那就是数学\N{\r原文字幕}which is mathematics and
Dialogue: 0,0:01:54.89,0:01:57.92,译文字幕,,0,0,0,,即今日之话题\N{\r原文字幕}that's what he's going to talk to us about today
Dialogue: 0,0:01:58.40,0:02:01.76,译文字幕,,0,0,0,,那么，掌声有请\N{\r原文字幕}so ladies and gentlemen please put your hands together
Dialogue: 0,0:02:01.50,0:02:04.00,译文字幕,,0,0,0,,今年（2013）的图灵奖得主\N{\r原文字幕}for this year's am Turing Award winner
Dialogue: 0,0:02:04.01,0:02:05.51,译文字幕,,0,0,0,,Leslie Lamport\N{\r原文字幕}Leslie Lamport
Dialogue: 0,0:02:10.94,0:02:12.53,译文字幕,,0,0,0,,感谢老铁\N{\r原文字幕}Thank You Judith
Dialogue: 0,0:02:14.72,0:02:16.85,译文字幕,,0,0,0,,thinking above the code（主题）\N{\r原文字幕}thinking above the code
Dialogue: 0,0:02:17.03,0:02:18.80,译文字幕,,0,0,0,,先说为啥思考\N{\r原文字幕}why do we think
Dialogue: 0,0:02:19.46,0:02:22.07,译文字幕,,0,0,0,,思考助你成事\N{\r原文字幕}well it helps us do most things
Dialogue: 0,0:02:22.43,0:02:28.79,译文字幕,,0,0,0,,比如打猎、盖房、写代码\N{\r原文字幕}like hunting a saber-toothed tiger or building a house or writing a program
Dialogue: 0,0:02:29.66,0:02:32.18,译文字幕,,0,0,0,,那么啥时候该思考\N{\r原文字幕}so when should we think
Dialogue: 0,0:02:32.81,0:02:39.68,译文字幕,,0,0,0,,对打猎来说，出发前\N{\r原文字幕}well hunting a saber-toothed tiger we should think before leaving the cave
Dialogue: 0,0:02:39.47,0:02:43.07,译文字幕,,0,0,0,,也就是被老虎发现前就应该思考\N{\r原文字幕}when the tiger is charging at you
Dialogue: 0,0:02:42.78,0:02:43.88,译文字幕,,0,0,0,,不然就完了\N{\r原文字幕}it's a little late
Dialogue: 0,0:02:44.18,0:02:48.50,译文字幕,,0,0,0,,盖房前就该思考\N{\r原文字幕}building a house before beginning construction
Dialogue: 0,0:02:48.56,0:02:51.23,译文字幕,,0,0,0,,当然\N{\r原文字幕}you don't want to think about what you're doing
Dialogue: 0,0:02:50.76,0:02:54.98,译文字幕,,0,0,0,,请个建筑师\N{\r原文字幕}when the Carpenters are putting the roof on
Dialogue: 0,0:02:55.40,0:02:58.22,译文字幕,,0,0,0,,来代替我们思考也行\N{\r原文字幕}allready start thinking about what you're doing
Dialogue: 0,0:02:58.31,0:03:04.85,译文字幕,,0,0,0,,写代码前应该思考\N{\r原文字幕}writing a program we should be thinking before we start writing any code
Dialogue: 0,0:03:06.11,0:03:07.67,译文字幕,,0,0,0,,那么怎么思考，how？\N{\r原文字幕}how to think
Dialogue: 0,0:03:09.71,0:03:13.52,译文字幕,,0,0,0,,我最喜欢Mr.CG说的一句话\N{\r原文字幕}when I favorite quotes is from the cartoonist Guindon
Dialogue: 0,0:03:13.67,0:03:19.64,译文字幕,,0,0,0,,”空想不如写下来“\N{\r原文字幕}who says writing is nature's way of letting you know how sloppy your thinking is
Dialogue: 0,0:03:20.12,0:03:24.71,译文字幕,,0,0,0,,真正的思考不是空想，是写下来\N{\r原文字幕}to think to really think you have to write
Dialogue: 0,0:03:24.42,0:03:27.17,译文字幕,,0,0,0,,如果只是拍脑袋\N{\r原文字幕}if you're thinking without writing
Dialogue: 0,0:03:27.62,0:03:30.17,译文字幕,,0,0,0,,那你是在骗自己\N{\r原文字幕}chances are you're fooling yourself
Dialogue: 0,0:03:29.90,0:03:33.71,译文字幕,,0,0,0,,是在假装思考\N{\r原文字幕}we're only pretending to think
Dialogue: 0,0:03:34.61,0:03:36.26,译文字幕,,0,0,0,,思考的时候该写什么？\N{\r原文字幕}what to write？
Dialogue: 0,0:03:36.86,0:03:39.71,译文字幕,,0,0,0,,对狩猎为生的上古\N{\r原文字幕}well hunting a saber-toothed tiger
Dialogue: 0,0:03:41.19,0:03:44.96,译文字幕,,0,0,0,,打猎非常危险，因为那时的人还不会写\N{\r原文字幕}writing wasn't invented then which meant it was a very dangerous activity
Dialogue: 0,0:03:46.85,0:03:48.41,译文字幕,,0,0,0,,对盖房来说\N{\r原文字幕}building a house
Dialogue: 0,0:03:49.19,0:03:54.98,译文字幕,,0,0,0,,你应该先整个蓝图\N{\r原文字幕}well what'd you write before you build to start building a house are called blueprints
Dialogue: 0,0:03:55.23,0:03:56.84,译文字幕,,0,0,0,,蓝色的图\N{\r原文字幕}and it's called drawing blueprints
Dialogue: 0,0:03:58.16,0:03:59.72,译文字幕,,0,0,0,,对写程序来说\N{\r原文字幕}writing a program
Dialogue: 0,0:04:00.11,0:04:04.34,译文字幕,,0,0,0,,coding之前也应该整个蓝图\N{\r原文字幕}well you should also write a blueprint of your program
Dialogue: 0,0:04:04.40,0:04:08.03,译文字幕,,0,0,0,,讲专业一点，那叫规范\N{\r原文字幕}but blueprints of programs are what we call specifications
Dialogue: 0,0:04:10.07,0:04:10.57,译文字幕,,0,0,0,,Specifications\N{\r原文字幕}specifications
Dialogue: 0,0:04:11.81,0:04:15.68,译文字幕,,0,0,0,,计算机人总是恐惧规范\N{\r原文字幕}well when I say the word people tend to panic
Dialogue: 0,0:04:15.75,0:04:21.55,译文字幕,,0,0,0,,因为这东西（规范）太正式了，看不懂\N{\r原文字幕}this formal stuff that's impossible to read and understand
Dialogue: 0,0:04:21.59,0:04:25.27,译文字幕,,0,0,0,,一大堆概念啊公式啊意向啊把人绕蒙了\N{\r原文字幕}and you have to learn these funny symbols and all that sort of stuff
Dialogue: 0,0:04:25.81,0:04:30.67,译文字幕,,0,0,0,,来看这个蓝图，足够复杂\N{\r原文字幕}yeah this is a blueprint you know all these complicated stuff going on
Dialogue: 0,0:04:30.61,0:04:32.86,译文字幕,,0,0,0,,但不是所有的蓝图都让人头大\N{\r原文字幕}but this is also a blueprint
Dialogue: 0,0:04:32.93,0:04:38.50,译文字幕,,0,0,0,,用光谱来表示蓝图的复杂度\N{\r原文字幕}in fact there's an entire spectrum of blueprints
Dialogue: 0,0:04:39.43,0:04:45.00,译文字幕,,0,0,0,,一边是复杂度拉满\N{\r原文字幕}ranging from very detailed complicated blueprints
Dialogue: 0,0:04:45.52,0:04:50.29,译文字幕,,0,0,0,,比如造这个桥需要的蓝图\N{\r原文字幕}which you need if you're building something that's very big and complicated
Dialogue: 0,0:04:50.83,0:04:52.63,译文字幕,,0,0,0,,另一边\N{\r原文字幕}at the other end
Dialogue: 0,0:04:52.67,0:04:58.09,译文字幕,,0,0,0,,可能只是个草图\N{\r原文字幕}they're just rough sketch of what you're building is just something you know really simple
Dialogue: 0,0:04:57.98,0:04:59.68,译文字幕,,0,0,0,,对小项目，足以\N{\r原文字幕}that you're gonna do in the weekend
Dialogue: 0,0:04:59.95,0:05:05.47,译文字幕,,0,0,0,,中间是一些典型的蓝图\N{\r原文字幕}and there are these ordinary blueprints for
Dialogue: 0,0:05:05.21,0:05:08.92,译文字幕,,0,0,0,,房子啊什么的\N{\r原文字幕}you know things like a house or the stuff
Dialogue: 0,0:05:08.69,0:05:13.90,译文字幕,,0,0,0,,这些东西的蓝图我们应该都见过\N{\r原文字幕}that kinds of blueprints that most of us might have seen
Dialogue: 0,0:05:14.41,0:05:17.95,译文字幕,,0,0,0,,同样的，对规范来说，也有光谱\N{\r原文字幕}and similarly there's a spectrum of specifications
Dialogue: 0,0:05:18.97,0:05:21.34,译文字幕,,0,0,0,,我们有贼正式的规范\N{\r原文字幕}there are formal specifications
Dialogue: 0,0:05:21.77,0:05:26.95,译文字幕,,0,0,0,,特别正式\N{\r原文字幕}and on the other end of the your formal specifications
Dialogue: 0,0:05:27.20,0:05:29.68,译文字幕,,0,0,0,,你得用精准的语言描述\N{\r原文字幕}written in a in a precise formal language
Dialogue: 0,0:05:29.60,0:05:33.31,译文字幕,,0,0,0,,另一边，可以是简短的规范\N{\r原文字幕}and on the other end there are just short prose specifications
Dialogue: 0,0:05:33.77,0:05:38.89,译文字幕,,0,0,0,,中间的，我称之为可数学描述的规范\N{\r原文字幕}and in the middle are what I like to call mathematical prose
Dialogue: 0,0:05:39.64,0:05:46.33,译文字幕,,0,0,0,,大多数code足够简单，两句话就能描述明白\N{\r原文字幕}most code is really simple few sentences of prose will do
Dialogue: 0,0:05:49.03,0:05:53.80,译文字幕,,0,0,0,,还有一些code，需要稍微花点心思描述\N{\r原文字幕}some code is subtle will requires more thought
Dialogue: 0,0:05:53.66,0:06:04.30,译文字幕,,0,0,0,,不用多正式，但你得小心描述\N{\r原文字幕}and for that you have to write it ’s prose but it's it try to be you need to be pretty precise
Dialogue: 0,0:06:04.28,0:06:10.81,译文字幕,,0,0,0,,最后剩下复杂的code\N{\r原文字幕}and some code is either very complex or very subtle or critical
Dialogue: 0,0:06:11.21,0:06:15.49,译文字幕,,0,0,0,,特别是在\N{\r原文字幕}and that's especially the case if what you're doing
Dialogue: 0,0:06:15.02,0:06:19.03,译文字幕,,0,0,0,,涉及到并发和分布式的项目中\N{\r原文字幕}is writing concurrent or distributed system
Dialogue: 0,0:06:18.95,0:06:23.35,译文字幕,,0,0,0,,复杂的code需要你花心思去构思\N{\r原文字幕}it is going to be complex and subtle and quite likely critical
Dialogue: 0,0:06:23.54,0:06:27.88,译文字幕,,0,0,0,,没有工具的话，这事就会非常烦人\N{\r原文字幕}and for that you should have tools
Dialogue: 0,0:06:27.83,0:06:29.50,译文字幕,,0,0,0,,如果使用工具来帮助我们\N{\r原文字幕}you should be using tools
Dialogue: 0,0:06:29.24,0:06:32.17,译文字幕,,0,0,0,,那就简单且安全\N{\r原文字幕}to check it to check your blueprints
Dialogue: 0,0:06:32.53,0:06:37.59,译文字幕,,0,0,0,,使用故居意味着我们需要一种正式的语言\N{\r原文字幕}and if you're going to use tools it means you need a formal language
Dialogue: 0,0:06:37.51,0:06:40.29,译文字幕,,0,0,0,,因为工具可不懂小作文\N{\r原文字幕}because tools don't understand prose
Dialogue: 0,0:06:40.62,0:06:42.78,译文字幕,,0,0,0,,那么，怎么写一个规范\N{\r原文字幕}so how to write a spec
Dialogue: 0,0:06:43.11,0:06:45.66,译文字幕,,0,0,0,,首先，要多想\N{\r原文字幕}well writing requires thinking
Dialogue: 0,0:06:46.23,0:06:49.44,译文字幕,,0,0,0,,那么写代码要怎么多想呢\N{\r原文字幕}so how to think about programs
Dialogue: 0,0:06:51.00,0:06:57.42,译文字幕,,0,0,0,,那就是像科学家一样思考\N{\r原文字幕}we should think about programs like computer scientists namely like scientists
Dialogue: 0,0:06:58.68,0:07:04.50,译文字幕,,0,0,0,,我们都知道科学的思考非常有用\N{\r原文字幕}scientific thinking is a very successful way of thinking we know all that it's brought us
Dialogue: 0,0:07:04.62,0:07:09.75,译文字幕,,0,0,0,,具体一点就是构建数学模型\N{\r原文字幕}what science does is make mathematical models of reality
Dialogue: 0,0:07:10.83,0:07:15.78,译文字幕,,0,0,0,,来看天文学的成功例子 \N{\r原文字幕}for example the first very successful science was astronomy
Dialogue: 0,0:07:17.16,0:07:22.83,译文字幕,,0,0,0,,真实的星球有海洋、陆地等\N{\r原文字幕}the reality planets have mountains oceans tides and weather
Dialogue: 0,0:07:22.51,0:07:24.84,译文字幕,,0,0,0,,太复杂不利于研究\N{\r原文字幕}and all sorts of complicating things
Dialogue: 0,0:07:24.96,0:07:32.88,译文字幕,,0,0,0,,于是天文学家将其\N{\r原文字幕}but the simple model that's gotten astronomy pretty far
Dialogue: 0,0:07:32.68,0:07:39.12,译文字幕,,0,0,0,, 抽象为一个有坐标有质量的点\N{\r原文字幕}is to think of a planet model the planet as a point mass having position and momentum
Dialogue: 0,0:07:40.29,0:07:45.48,译文字幕,,0,0,0,,计算机科学中有很多设备\N{\r原文字幕}computer science the reality consists of digital systems
Dialogue: 0,0:07:45.63,0:07:51.66,译文字幕,,0,0,0,,处理器、手柄\N{\r原文字幕}things like a processor chip 、a game console or a computer executing a program
Dialogue: 0,0:07:53.37,0:07:57.48,译文字幕,,0,0,0,,执行程序的电脑等\N{\r原文字幕}this is what I'll be talking about computer is executing programs
Dialogue: 0,0:07:57.75,0:08:03.18,译文字幕,,0,0,0,,这些东西都可被抽象（被model）\N{\r原文字幕}but what I have to say applies to all those other things just as well
Dialogue: 0,0:08:03.78,0:08:08.67,译文字幕,,0,0,0,,图灵机中\N{\r原文字幕}so models there are lots of models that you've probably come across
Dialogue: 0,0:08:08.23,0:08:13.29,译文字幕,,0,0,0,,也有很多抽象（models）\N{\r原文字幕}Turing machines partially ordered set of events you probably haven't run across that
Dialogue: 0,0:08:13.30,0:08:23.37,译文字幕,,0,0,0,,但是对我而言，就两个model最有用\N{\r原文字幕}and lots of models but - to my mind stand out as being the most useful basic models
Dialogue: 0,0:08:24.15,0:08:28.05,译文字幕,,0,0,0,,函数和状态序列\N{\r原文字幕}functions and sequences of states
Dialogue: 0,0:08:28.86,0:08:36.48,译文字幕,,0,0,0,,我们把一段程序看做函数\N{\r原文字幕}so functions we model a function of a we can model a program as a function
Dialogue: 0,0:08:36.67,0:08:40.92,译文字幕,,0,0,0,,具体的，他是一个输入到输出的映射\N{\r原文字幕}that map's an input or to an output
Dialogue: 0,0:08:40.84,0:08:45.51,译文字幕,,0,0,0,,可能一个多个输入到一个输出，也可能没有输入输出\N{\r原文字幕}or multiple inputs - or possible inputs to possible outputs
Dialogue: 0,0:08:46.01,0:08:48.46,译文字幕,,0,0,0,,数学上的函数非常简单\N{\r原文字幕}in math the function is very simple
Dialogue: 0,0:08:48.50,0:08:50.92,译文字幕,,0,0,0,,即函数是有序对（input->output）的集合\N{\r原文字幕}it's an order as a set of ordered pairs
Dialogue: 0,0:08:50.45,0:08:55.48,译文字幕,,0,0,0,,来看自然数上得平方函数\N{\r原文字幕}so for example the square function on natural numbers
Dialogue: 0,0:08:55.42,0:09:01.48,译文字幕,,0,0,0,,它由这样的配对构成 0-> 0 、1-> 1 、2-> 4\N{\r原文字幕}it's this set of ordered pairs this pair 0-> 0 、1-> 1 、2-> 4 etc
Dialogue: 0,0:09:01.58,0:09:09.94,译文字幕,,0,0,0,,具体来看2->4\N{\r原文字幕}and the element 2-> 4 is an element of this set of the fact that the outlet that
Dialogue: 0,0:09:09.47,0:09:15.85,译文字幕,,0,0,0,,它被表示为\N{\r原文字幕}the pair 2-> 4 is an element of this square function is usually expressed
Dialogue: 0,0:09:16.01,0:09:18.91,译文字幕,,0,0,0,,2的平方等于4\N{\r原文字幕}by saying square of 2 equals 4
Dialogue: 0,0:09:19.69,0:09:27.40,译文字幕,,0,0,0,,定义域是所有pair中的第一个元素的集合\N{\r原文字幕}now the domain of of square the domain of a function are all the first elements of those pairs
Dialogue: 0,0:09:27.29,0:09:33.85,译文字幕,,0,0,0,,这里平方函数的定义域就是0 1 2 3等\N{\r原文字幕}so for the square function the domain is the set number 0 1 2 & 3 etc
Dialogue: 0,0:09:33.94,0:09:38.77,译文字幕,,0,0,0,,即自然数，常记作N\N{\r原文字幕}also known as the natural numbers that I like to write as n
Dialogue: 0,0:09:39.70,0:09:45.64,译文字幕,,0,0,0,,定义函数的第一步是确定定义域\N{\r原文字幕}to specify to define a function what you do is you specify its domain
Dialogue: 0,0:09:45.56,0:09:50.77,译文字幕,,0,0,0,,就像这里的平方函数的定义域是自然数\N{\r原文字幕}so to specify square we say the domain of square is equal to the set of Naturals
Dialogue: 0,0:09:50.81,0:09:55.06,译文字幕,,0,0,0,,对定义域中的所有元素X\N{\r原文字幕}and for each element X in its domain
Dialogue: 0,0:09:55.12,0:10:00.70,译文字幕,,0,0,0,,函数Square都\N{\r原文字幕}we specify what Square maps X to
Dialogue: 0,0:10:00.53,0:10:03.67,译文字幕,,0,0,0,,将其映射为X的平方\N{\r原文字幕}and it maps the value X to x squared
Dialogue: 0,0:10:03.59,0:10:06.79,译文字幕,,0,0,0,,这就是Square函数的定义\N{\r原文字幕}so that defines the square function
Dialogue: 0,0:10:07.42,0:10:13.33,译文字幕,,0,0,0,,数学中的函数和程序中的函数不同\N{\r原文字幕}now functions in math are not the same as functions in programming languages
Dialogue: 0,0:10:13.45,0:10:15.37,译文字幕,,0,0,0,,数学中更简单\N{\r原文字幕}math is much simpler
Dialogue: 0,0:10:15.26,0:10:16.99,译文字幕,,0,0,0,,我不是程序语言专家\N{\r原文字幕}I'm not a programming language expert
Dialogue: 0,0:10:17.24,0:10:22.03,译文字幕,,0,0,0,,所以我不太了解程序中的函数（function）\N{\r原文字幕}so I don't know what those things that programming languages
Dialogue: 0,0:10:22.04,0:10:23.29,译文字幕,,0,0,0,,但我知道数学上\N{\r原文字幕}which is called functions are
Dialogue: 0,0:10:23.11,0:10:27.79,译文字幕,,0,0,0,,函数更为简单\N{\r原文字幕}but I know what math is that methods are a lot simpler
Dialogue: 0,0:10:28.18,0:10:32.56,译文字幕,,0,0,0,,函数模型非常有用\N{\r原文字幕}now the functions model will take you very far it's very useful
Dialogue: 0,0:10:32.66,0:10:34.24,译文字幕,,0,0,0,,但是仍有限制\N{\r原文字幕}but there has limitations
Dialogue: 0,0:10:35.14,0:10:42.91,译文字幕,,0,0,0,,它只是定义了程序该做什么，但没说怎么做\N{\r原文字幕}its limitation main limitation is that it specifies what a program does but not how it does it
Dialogue: 0,0:10:43.06,0:10:48.46,译文字幕,,0,0,0,,例如，快排和冒泡都是排序算法\N{\r原文字幕}so for example quick sort and bubble sort compute the same function
Dialogue: 0,0:10:49.48,0:10:52.45,译文字幕,,0,0,0,,但显然他们的实现是不同的\N{\r原文字幕}but they're very different programs
Dialogue: 0,0:10:53.56,0:10:57.91,译文字幕,,0,0,0,,此外，一些程序压根没有输入输出\N{\r原文字幕}also some programs don't just map inputs to outputs
Dialogue: 0,0:10:58.99,0:11:02.85,译文字幕,,0,0,0,,还有一些没有结果\N{\r原文字幕}some programs run forever well you know they may stop
Dialogue: 0,0:11:02.71,0:11:07.71,译文字幕,,0,0,0,,也就是那些会一直运行的程序\N{\r原文字幕}before the the Sun explodes but it's useful to think of them it's running forever
Dialogue: 0,0:11:07.86,0:11:13.05,译文字幕,,0,0,0,,比如操作系统，简单的将之抽象位函数是没有意义的\N{\r原文字幕}for example operating systems you can't specify an operating system as a function
Dialogue: 0,0:11:13.09,0:11:15.45,译文字幕,,0,0,0,,因为它不是输入映射到输出的形式\N{\r原文字幕}because it doesn't map inputs to outputs
Dialogue: 0,0:11:15.90,0:11:22.02,译文字幕,,0,0,0,,因为上述的这些限制，所以我不将规范定义为函数\N{\r原文字幕}so for that for those specifications use what I like to call
Dialogue: 0,0:11:21.67,0:11:23.73,译文字幕,,0,0,0,,我称之为标准行为模型\N{\r原文字幕}the standard behavioral model
Dialogue: 0,0:11:23.56,0:11:28.71,译文字幕,,0,0,0,,这样的话程序的执行被视为行为\N{\r原文字幕}in which a program execution is represented by a behavior
Dialogue: 0,0:11:29.02,0:11:33.90,译文字幕,,0,0,0,,行为是一个状态序列\N{\r原文字幕}a behavior is a sequence of states
Dialogue: 0,0:11:33.70,0:11:38.91,译文字幕,,0,0,0,,状态是变量的某一个赋值（即某一个时刻的值）\N{\r原文字幕}and a state is an assignment of values to variables
Dialogue: 0,0:11:39.18,0:11:44.40,译文字幕,,0,0,0,,如此，程序可以抽象为行为集合\N{\r原文字幕}and a program is modeled by a set of behaviors
Dialogue: 0,0:11:44.28,0:11:49.22,译文字幕,,0,0,0,,程序的所有执行都称为行为\N{\r原文字幕}which behaviors that represent all possible executions of the program
Dialogue: 0,0:11:49.80,0:11:53.31,译文字幕,,0,0,0,,具体来看欧几里得算法\N{\r原文字幕}so for example let's look at Euclid's algorithm
Dialogue: 0,0:11:53.17,0:11:56.73,译文字幕,,0,0,0,,一个你们都知道\N{\r原文字幕}an algorithm is just an abstract program
Dialogue: 0,0:11:57.54,0:12:00.42,译文字幕,,0,0,0,,的算法\N{\r原文字幕}as you all undoubtedly know
Dialogue: 0,0:12:00.13,0:12:05.94,译文字幕,,0,0,0,,它计算两个自然数m和n的最大公约数\N{\r原文字幕}it computes the greatest common divisor of two natural of two integers m and n
Dialogue: 0,0:12:05.56,0:12:08.76,译文字幕,,0,0,0,,先初始化：x=m；y=n\N{\r原文字幕}by initializing x to m and y to m
Dialogue: 0,0:12:08.53,0:12:13.14,译文字幕,,0,0,0,,然后大数减小数\N{\r原文字幕}and then it keeps subtracting the smaller from the larger
Dialogue: 0,0:12:12.79,0:12:17.70,译文字幕,,0,0,0,,直到x=y\N{\r原文字幕}and when x and y are equal then it stops
Dialogue: 0,0:12:17.71,0:12:21.93,译文字幕,,0,0,0,,这个相等的数就是最大公约数\N{\r原文字幕}because that x and y equals the GCD of M and n
Dialogue: 0,0:12:22.11,0:12:28.38,译文字幕,,0,0,0,,来看一个例子 M=12 N=18\N{\r原文字幕}so for M = 12 and N = 18 there's just one possible behavior
Dialogue: 0,0:12:28.33,0:12:34.50,译文字幕,,0,0,0,,初始化：x=12；y=18\N{\r原文字幕}it starts with a state in which that assigns 12 to X and 18 to Y
Dialogue: 0,0:12:34.18,0:12:38.07,译文字幕,,0,0,0,,通过一步减法得到下一个状态\N{\r原文字幕}and then subtract the next state is obtained by
Dialogue: 0,0:12:37.78,0:12:41.19,译文字幕,,0,0,0,,该减法描述为用xy中的大数减小数\N{\r原文字幕}subtracting the smaller one from the larger X from Y
Dialogue: 0,0:12:40.90,0:12:47.34,译文字幕,,0,0,0,,next state：x=12；y=y-x=18-12=6\N{\r原文字幕}so you get reach a state where x equals 12 and y equals 18 minus 12 or 6
Dialogue: 0,0:12:47.20,0:12:53.97,译文字幕,,0,0,0,,然后再次从xy中大数减小数\N{\r原文字幕}and in the next state you subtract the smaller which is y from the larger and you wind up in the state
Dialogue: 0,0:12:53.74,0:12:56.34,译文字幕,,0,0,0,,next state：x=x-y=12-6=6；y=6\N{\r原文字幕}in which x equals 6 and y equals 6
Dialogue: 0,0:12:56.08,0:12:58.80,译文字幕,,0,0,0,,此时x=y=6，最大公约数是6\N{\r原文字幕}and since x and y are equal you stop
Dialogue: 0,0:12:58.59,0:13:01.02,译文字幕,,0,0,0,,简单吧\N{\r原文字幕}so it's very simple algorithm
Dialogue: 0,0:13:00.88,0:13:03.45,译文字幕,,0,0,0,,它只有一种行为\N{\r原文字幕}it has just one possible behavior
Dialogue: 0,0:13:04.35,0:13:07.56,译文字幕,,0,0,0,,好了，那我们怎么描述行为集合\N{\r原文字幕}so how do we describe a set of behaviors
Dialogue: 0,0:13:08.52,0:13:10.80,译文字幕,,0,0,0,,首先，我先提个理论奥\N{\r原文字幕}well first of all there's a theorem
Dialogue: 0,0:13:11.10,0:13:14.49,译文字幕,,0,0,0,,有行为集合B\N{\r原文字幕}that says any set B of behaviors
Dialogue: 0,0:13:14.56,0:13:20.19,译文字幕,,0,0,0,,B有两个子集\N{\r原文字幕}is the conjunct the intersection of two sets
Dialogue: 0,0:13:19.96,0:13:23.91,译文字幕,,0,0,0,,一个子集满足安全\N{\r原文字幕}a set of behaviors satisfying a safety property
Dialogue: 0,0:13:23.95,0:13:28.32,译文字幕,,0,0,0,,一个子集满足活性\N{\r原文字幕}and a set of behaviors satisfying a liveness property
Dialogue: 0,0:13:28.62,0:13:30.90,译文字幕,,0,0,0,,额，啥是安全，啥是活性\N{\r原文字幕}so what our safety and liveness
Dialogue: 0,0:13:30.84,0:13:34.14,译文字幕,,0,0,0,,官方定义先不谈\N{\r原文字幕}well I'm not going to bother going into you know
Dialogue: 0,0:13:33.67,0:13:38.19,译文字幕,,0,0,0,,简而言之，当程序的某一行为会出错退出时\N{\r原文字幕}the formal definitions but a safety property is false if and only if
Dialogue: 0,0:13:37.90,0:13:41.85,译文字幕,,0,0,0,,我们就说它没有安全性\N{\r原文字幕}it can be violated at some point during the behavior
Dialogue: 0,0:13:42.06,0:13:45.36,译文字幕,,0,0,0,,来看局部正确的例子\N{\r原文字幕}so partial correctness is an example
Dialogue: 0,0:13:45.19,0:13:50.49,译文字幕,,0,0,0,,当得到期望之外的答案时，局部正确性被破坏\N{\r原文字幕}partial correctness is violated if the program stops with the wrong answer
Dialogue: 0,0:13:50.26,0:13:53.64,译文字幕,,0,0,0,,在行为的某一点上\N{\r原文字幕}so that's some point in the behavior
Dialogue: 0,0:13:53.62,0:13:57.57,译文字幕,,0,0,0,,属性被破坏了\N{\r原文字幕}you can tell that it that it the property was violated
Dialogue: 0,0:13:57.61,0:14:01.70,译文字幕,,0,0,0,,这个点就是程序因错误而退出的点\N{\r原文字幕}the point at which the program stopped with the incorrect answer
Dialogue: 0,0:14:02.52,0:14:05.10,译文字幕,,0,0,0,,再来看活性\N{\r原文字幕}the liveness property is one
Dialogue: 0,0:14:04.81,0:14:08.91,译文字幕,,0,0,0,,为了判断程序是否满足活性\N{\r原文字幕}in which you need to see the complete behavior in order to know if it's false
Dialogue: 0,0:14:08.68,0:14:13.53,译文字幕,,0,0,0,,你必须观察整个行为\N{\r原文字幕}or if it's not satisfied by the by the program
Dialogue: 0,0:14:13.48,0:14:15.60,译文字幕,,0,0,0,,典型的例子是termination\N{\r原文字幕}classic example is termination
Dialogue: 0,0:14:15.82,0:14:18.57,译文字幕,,0,0,0,,你不能仅仅通过观察一段程序\N{\r原文字幕}you can't tell that the program hasn't terminated
Dialogue: 0,0:14:18.91,0:14:21.99,译文字幕,,0,0,0,,就说程序已经停止了\N{\r原文字幕}by looking at any finite piece of the program
Dialogue: 0,0:14:21.91,0:14:25.56,译文字幕,,0,0,0,,你必须观察所有行为才能知道他是否停止了\N{\r原文字幕}you have to look at the entire behavior to know that it never terminates
Dialogue: 0,0:14:25.83,0:14:31.59,译文字幕,,0,0,0,,因此我们用\N{\r原文字幕}so we satisfy specify a set of behaviors with by specifying a
Dialogue: 0,0:14:31.30,0:14:33.09,译文字幕,,0,0,0,,安全和活性来定义行为集合\N{\r原文字幕}safety property and aliveness property
Dialogue: 0,0:14:33.78,0:14:39.00,译文字幕,,0,0,0,,在实践中，安全性更为重要\N{\r原文字幕}now in practice specifying safety just turns out to be more important
Dialogue: 0,0:14:39.33,0:14:45.72,译文字幕,,0,0,0,,因为这是最有可能发生错误的地方 而且往往更微妙\N{\r原文字幕}because that's where errors are most likely to occur and tend to be more subtle
Dialogue: 0,0:14:45.64,0:14:48.84,译文字幕,,0,0,0,,活性也很重要\N{\r原文字幕}I mean liveness is important just not as important to safety
Dialogue: 0,0:14:48.76,0:14:52.49,译文字幕,,0,0,0,,但时间关系，今天不谈\N{\r原文字幕}and so to save time I'm going to ignore aliveness today
Dialogue: 0,0:14:52.99,0:14:54.69,译文字幕,,0,0,0,,只谈安全性\N{\r原文字幕}and just talk about safety
Dialogue: 0,0:14:54.87,0:14:58.38,译文字幕,,0,0,0,,好，如何定义安全性\N{\r原文字幕}so how to specify a safety property
Dialogue: 0,0:14:58.33,0:15:00.96,译文字幕,,0,0,0,,我们使用俩东西定义安全性\N{\r原文字幕}we specify it with two things
Dialogue: 0,0:15:01.05,0:15:03.90,译文字幕,,0,0,0,,1. 可能的初始状态集合\N{\r原文字幕}the set of possible initial States
Dialogue: 0,0:15:03.88,0:15:06.54,译文字幕,,0,0,0,,2. 步进到下一状态的关系\N{\r原文字幕}and the next state relation
Dialogue: 0,0:15:06.70,0:15:10.83,译文字幕,,0,0,0,,步进关系描述了一个状态的所有先驱状态\N{\r原文字幕}which describes all possible successor states
Dialogue: 0,0:15:10.72,0:15:15.99,译文字幕,,0,0,0,,好的，那我们该使用什么语言来描述这两个东西呢\N{\r原文字幕}of any state so what language should we use to write these things
Dialogue: 0,0:15:16.32,0:15:18.84,译文字幕,,0,0,0,,想想科学家会怎么做\N{\r原文字幕}well let's act like scientists
Dialogue: 0,0:15:18.88,0:15:22.41,译文字幕,,0,0,0,,科学家用啥语言\N{\r原文字幕}what language do mathema two scientists use
Dialogue: 0,0:15:22.09,0:15:24.24,译文字幕,,0,0,0,,用数学\N{\r原文字幕}and the language is mathematics
Dialogue: 0,0:15:24.43,0:15:26.37,译文字幕,,0,0,0,,最科学的语言\N{\r原文字幕}that's the language of science
Dialogue: 0,0:15:26.26,0:15:29.94,译文字幕,,0,0,0,,他们用公式描述初态集合\N{\r原文字幕}so the set of initial states they're described by a formula
Dialogue: 0,0:15:29.97,0:15:36.63,译文字幕,,0,0,0,,在欧几里得算法中，初态就是\N{\r原文字幕}so in Euclid's algorithm the set of initial States we initialize the initial state is one
Dialogue: 0,0:15:36.28,0:15:38.82,译文字幕,,0,0,0,,(x=m)^(y=n)\N{\r原文字幕}in which X = M and Y = N
Dialogue: 0,0:15:38.50,0:15:42.93,译文字幕,,0,0,0,,这就是用公式表示初态\N{\r原文字幕}so that is specified that initial state is specified by this formula
Dialogue: 0,0:15:43.29,0:15:50.73,译文字幕,,0,0,0,,这里只有一种初态\N{\r原文字幕}and the only part this has only one it's only one possible initial state that satisfies that formula
Dialogue: 0,0:15:51.81,0:15:55.74,译文字幕,,0,0,0,,步进关系依然使用公式表示\N{\r原文字幕}the next state relation is also described by a formula
Dialogue: 0,0:15:55.81,0:15:58.32,译文字幕,,0,0,0,,为了描述它\N{\r原文字幕}and to describe it
Dialogue: 0,0:15:58.06,0:16:05.64,译文字幕,,0,0,0,,我使用不带撇变量来描述当前状态或者初态\N{\r原文字幕}I'll use unprimed variables to talk about the current state or the first state of the pair
Dialogue: 0,0:16:05.38,0:16:08.97,译文字幕,,0,0,0,,使用带撇变量来表示next state\N{\r原文字幕}and prime variables we're talking about the next state
Dialogue: 0,0:16:08.94,0:16:12.99,译文字幕,,0,0,0,,好，我们来看欧几里得算法的步进关系\N{\r原文字幕}so let's look at the next state relation for Euclid's algorithm
Dialogue: 0,0:16:12.82,0:16:14.52,译文字幕,,0,0,0,,有两种可能\N{\r原文字幕}there are two possibilities
Dialogue: 0,0:16:14.56,0:16:18.24,译文字幕,,0,0,0,,x>y or x<y\N{\r原文字幕}either X is greater than Y or Y is greater than X
Dialogue: 0,0:16:18.04,0:16:21.15,译文字幕,,0,0,0,,公式表示为\N{\r原文字幕}so that formula is going to be the
Dialogue: 0,0:16:20.86,0:16:23.01,译文字幕,,0,0,0,,两个公式\N{\r原文字幕}disjunction of two of two formulas
Dialogue: 0,0:16:24.27,0:16:30.27,译文字幕,,0,0,0,,看图别看字幕\N{\r原文字幕}if X is greater than Y then the new value of x prime
Dialogue: 0,0:16:30.57,0:16:35.25,译文字幕,,0,0,0,,不行就暂停慢慢捋\N{\r原文字幕}is equal to what you get by subtracting Y from it
Dialogue: 0,0:16:34.96,0:16:39.15,译文字幕,,0,0,0,,继续看图\N{\r原文字幕}so it's new value of x prime is equal to the old value of
Dialogue: 0,0:16:38.68,0:16:40.74,原文字幕,,0,0,0,,X minus the old value of y
Dialogue: 0,0:16:40.57,0:16:45.21,原文字幕,,0,0,0,,and the new value of X of Y is equal to the old value
Dialogue: 0,0:16:45.42,0:16:52.83,译文字幕,,0,0,0,,如图，第一个公式描述了所有满足x>y\N{\r原文字幕}so that first formula is specified by all pairs of states satisfying X
Dialogue: 0,0:16:52.66,0:16:55.14,译文字幕,,0,0,0,,的步进关系\N{\r原文字幕}greater than Y and in the initial state
Dialogue: 0,0:16:55.15,0:16:57.84,原文字幕,,0,0,0,,in first state X prime equals x minus y
Dialogue: 0,0:16:57.85,0:17:02.45,原文字幕,,0,0,0,,and y prime equals y were okay
Dialogue: 0,0:17:02.95,0:17:05.55,译文字幕,,0,0,0,,自行体会\N{\r原文字幕}you understand what what I said
Dialogue: 0,0:17:05.55,0:17:08.70,译文字幕,,0,0,0,,这描述了一种可能\N{\r原文字幕}and that describes one one possibility
Dialogue: 0,0:17:08.71,0:17:12.00,译文字幕,,0,0,0,,来看另一种可能\N{\r原文字幕}or the disjunction of these formulas to the other case
Dialogue: 0,0:17:11.80,0:17:16.29,译文字幕,,0,0,0,,看图\N{\r原文字幕}it's or what Y is greater than X in the first state
Dialogue: 0,0:17:16.09,0:17:20.49,原文字幕,,0,0,0,,and the value of y the new state and the value of y in the old state minus
Dialogue: 0,0:17:20.56,0:17:22.50,原文字幕,,0,0,0,,the value of x in the old state etc
Dialogue: 0,0:17:22.38,0:17:28.11,译文字幕,,0,0,0,,好了，图上的这两个式子描述了欧几里得算法的步进关系\N{\r原文字幕}so this simple formula describes the next state ratio relation of Euclid's algorithm
Dialogue: 0,0:17:28.14,0:17:31.68,译文字幕,,0,0,0,,具体来看其执行过程\N{\r原文字幕}so let's see how it works
Dialogue: 0,0:17:31.59,0:17:35.34,译文字幕,,0,0,0,,从这两个式子怎么得出行为\N{\r原文字幕}how you get behaviors out of those two formulas
Dialogue: 0,0:17:36.00,0:17:41.54,译文字幕,,0,0,0,,继续看图\N{\r原文字幕}well for example for an example I'll take em equal to 12 and N equals 18
Dialogue: 0,0:17:41.72,0:17:46.21,原文字幕,,0,0,0,,so to get the initial state we look at the initial predicate s-- predicate
Dialogue: 0,0:17:46.71,0:17:52.70,原文字幕,,0,0,0,,and we substitute 12 for m and 18 for n
Dialogue: 0,0:17:52.35,0:17:55.76,原文字幕,,0,0,0,,for what for n rather and you see you under
Dialogue: 0,0:17:55.44,0:18:00.29,原文字幕,,0,0,0,,that substitution there's only one pair of values x and y that satisfy this
Dialogue: 0,0:17:59.85,0:18:02.42,原文字幕,,0,0,0,,relation x equals 12 and y equals 18
Dialogue: 0,0:18:03.77,0:18:07.34,原文字幕,,0,0,0,,so to get the next state the second state
Dialogue: 0,0:18:07.05,0:18:09.56,原文字幕,,0,0,0,,we apply the next state look formula
Dialogue: 0,0:18:10.37,0:18:14.03,原文字幕,,0,0,0,,substituting 12 for x and 18 for y
Dialogue: 0,0:18:13.71,0:18:21.98,原文字幕,,0,0,0,,and we do that notice that 12 greater than 18 is false and 18 greater than 12 is true
Dialogue: 0,0:18:21.86,0:18:27.74,原文字幕,,0,0,0,,we'll false and anything is false so that first half of the formula is false
Dialogue: 0,0:18:27.98,0:18:32.12,原文字幕,,0,0,0,,true in anything is people to the rest of the formula
Dialogue: 0,0:18:32.15,0:18:39.26,原文字幕,,0,0,0,,so this formula is satisfied by the old value of x being 12
Dialogue: 0,0:18:39.18,0:18:44.06,原文字幕,,0,0,0,,and the new value of x being 18 minus 12 or 6
Dialogue: 0,0:18:44.63,0:18:52.85,原文字幕,,0,0,0,,so this is the only possible next state that satisfies this next relation
Dialogue: 0,0:18:52.94,0:18:57.83,原文字幕,,0,0,0,,when for the initial state x equals 12 and y equals 18
Dialogue: 0,0:18:58.79,0:19:03.47,原文字幕,,0,0,0,,okay to find the next state we do the same thing we
Dialogue: 0,0:19:03.66,0:19:07.09,原文字幕,,0,0,0,,substitute 12 for X and wife and 6 for y
Dialogue: 0,0:19:07.10,0:19:14.54,原文字幕,,0,0,0,,we simplify we see that 6 greater than 12 is false and 12 greater than 6 is true
Dialogue: 0,0:19:14.37,0:19:21.14,原文字幕,,0,0,0,,so the formula simplifies to x prime equals 12 minus 6 and y prime equals 6
Dialogue: 0,0:19:22.37,0:19:26.93,原文字幕,,0,0,0,,so it tells us that the only possible successor state
Dialogue: 0,0:19:26.73,0:19:34.10,原文字幕,,0,0,0,,the only possible third state is x equals 6 and y equals 6 and to find the next state
Dialogue: 0,0:19:33.84,0:19:40.19,原文字幕,,0,0,0,,well do the same thing we substitute 6 for X and 6 for y and we see
Dialogue: 0,0:19:39.93,0:19:42.95,原文字幕,,0,0,0,,that the entire formula is false
Dialogue: 0,0:19:42.78,0:19:48.71,原文字幕,,0,0,0,,and there are no values of x prime and y prime which can make the formula false true
Dialogue: 0,0:19:49.53,0:19:51.14,原文字幕,,0,0,0,,so there is no next state
Dialogue: 0,0:19:50.85,0:19:54.56,原文字幕,,0,0,0,,so there's no next state means the program is stopped
Dialogue: 0,0:19:54.86,0:19:57.23,译文字幕,,0,0,0,,这就是欧几里得算法\N{\r原文字幕}so that's Euclid's algorithm
Dialogue: 0,0:19:57.77,0:20:03.38,译文字幕,,0,0,0,,我们再来看看欧几里得算法\N{\r原文字幕}and when we see special about Euclid's algorithm is for any values of x and y
Dialogue: 0,0:20:03.03,0:20:06.50,译文字幕,,0,0,0,,我们按照公式\N{\r原文字幕}there are unique values of x prime and y prime
Dialogue: 0,0:20:06.24,0:20:08.09,译文字幕,,0,0,0,,总能找到对应的路径\N{\r原文字幕}that make next true
Dialogue: 0,0:20:07.95,0:20:10.82,译文字幕,,0,0,0,,其中一条状态或者相等状态\N{\r原文字幕}there's either one value or no values
Dialogue: 0,0:20:11.39,0:20:14.09,译文字幕,,0,0,0,,因此欧几里得算法是deterministic（有确定解）\N{\r原文字幕}so Euclid's algorithm is deterministic
Dialogue: 0,0:20:14.54,0:20:16.82,译文字幕,,0,0,0,,那non-determinism呢？\N{\r原文字幕}to model their non determinism
Dialogue: 0,0:20:17.30,0:20:20.06,译文字幕,,0,0,0,,我们就只有让步进关系\N{\r原文字幕}we just have a next state relation
Dialogue: 0,0:20:20.19,0:20:23.54,译文字幕,,0,0,0,,允许当前状态可能有多个next state\N{\r原文字幕}that allows multiple next States for a current state
Dialogue: 0,0:20:23.25,0:20:26.39,译文字幕,,0,0,0,,这可太难了\N{\r原文字幕}there's nothing magic you know terribly difficult
Dialogue: 0,0:20:26.10,0:20:29.51,译文字幕,,0,0,0,,非确定解可太难了\N{\r原文字幕}you know hard about can about non determinism
Dialogue: 0,0:20:30.50,0:20:33.44,译文字幕,,0,0,0,,变量的多重赋值\N{\r原文字幕}multiple assignments of values to prime variables
Dialogue: 0,0:20:33.57,0:20:38.30,译文字幕,,0,0,0,,对于单个变量多重赋值以使next为真\N{\r原文字幕}that make next true for a single assignment of values to unprimed variables
Dialogue: 0,0:20:38.31,0:20:41.09,译文字幕,,0,0,0,,这就是非确定解\N{\r原文字幕}that's what non determinism is all about
Dialogue: 0,0:20:41.27,0:20:43.67,译文字幕,,0,0,0,,ok 那正式的规范呢？\N{\r原文字幕}okay what about formal specs
Dialogue: 0,0:20:44.06,0:20:48.38,译文字幕,,0,0,0,,我们使用正式规范是为了使用工具\N{\r原文字幕}we need formal specifications only to apply tools
Dialogue: 0,0:20:48.45,0:20:53.33,译文字幕,,0,0,0,,数学家在有工具之前\N{\r原文字幕}we mathematicians you know before there were any tools you know wrote math
Dialogue: 0,0:20:53.19,0:20:55.55,译文字幕,,0,0,0,,记录数学信息\N{\r原文字幕}you know very you know an informal notation
Dialogue: 0,0:20:55.62,0:21:00.44,译文字幕,,0,0,0,,他们想使用一种数学语言来记录\N{\r原文字幕}they want to use Mathematica though they have to you know write in the language Mathematica
Dialogue: 0,0:21:00.63,0:21:04.64,译文字幕,,0,0,0,,因此我们需要使用一种规范语言来使用工具\N{\r原文字幕}so if we want to apply of tools we need a formal language
Dialogue: 0,0:21:04.29,0:21:07.64,译文字幕,,0,0,0,,这就是\N{\r原文字幕}and the language that I'm going to describe were
Dialogue: 0,0:21:07.50,0:21:09.74,译文字幕,,0,0,0,,TLA+\N{\r原文字幕}I use is called TLA plus
Dialogue: 0,0:21:09.92,0:21:18.89,译文字幕,,0,0,0,,来看公式在TLA+中的表示\N{\r原文字幕}so this this pair of formulas are written just like this in TLA plus
Dialogue: 0,0:21:20.12,0:21:25.52,译文字幕,,0,0,0,,我们需要一些声明\N{\r原文字幕}we need to form a language we need to write declarations
Dialogue: 0,0:21:25.80,0:21:29.72,译文字幕,,0,0,0,,声明常量M和N，变量x和y\N{\r原文字幕}we declare m and n to be constants and x and y to be variables
Dialogue: 0,0:21:30.20,0:21:35.33,译文字幕,,0,0,0,,然后界定边界，这里是都是整数\N{\r原文字幕}and then add a little boilerplate we said it extends the integers
Dialogue: 0,0:21:35.43,0:21:41.24,译文字幕,,0,0,0,,或者是一些定义了加减大小的标准\N{\r原文字幕}the integer or a standard module that defines things like plus and minus and greater than
Dialogue: 0,0:21:40.83,0:21:44.87,译文字幕,,0,0,0,,然后用一个MODULE括起来\N{\r原文字幕}and we put them inside of a module which I've called module Euclid
Dialogue: 0,0:21:44.76,0:21:48.62,译文字幕,,0,0,0,,这就是欧几里得算法的TLA+规范\N{\r原文字幕}and that's a TL A+ specification of Euclid's algorithm
Dialogue: 0,0:21:48.39,0:21:50.99,译文字幕,,0,0,0,,就这样\N{\r原文字幕}and this is what it looks like in SK
Dialogue: 0,0:21:53.39,0:21:57.14,译文字幕,,0,0,0,,现在你可以检查这个规范\N{\r原文字幕}now you can model check TLA plus specs
Dialogue: 0,0:21:57.20,0:22:08.25,译文字幕,,0,0,0,,模型检查是一种在小模型中检查所有可能的概念\N{\r原文字幕}know model checking conceptually checks all possible confusions of the program on a very small model
Dialogue: 0,0:22:10.83,0:22:16.92,译文字幕,,0,0,0,,高效且简单\N{\r原文字幕}it's extremely effective and quite easy to do
Dialogue: 0,0:22:16.89,0:22:21.21,译文字幕,,0,0,0,,你只需要简单的告诉checker模型的定义\N{\r原文字幕}you know you basically tell the model checker what the model is
Dialogue: 0,0:22:20.86,0:22:24.54,译文字幕,,0,0,0,,模型通常是一些常量赋值\N{\r原文字幕}models are usually you know instantiating values of constants
Dialogue: 0,0:22:24.52,0:22:27.63,译文字幕,,0,0,0,,在欧几里得算法中，我们需要告诉checker m和n是什么\N{\r原文字幕}so for Euclid's algorithm we'd have to tell it what m and n equals
Dialogue: 0,0:22:27.49,0:22:29.82,译文字幕,,0,0,0,,然后他就开始检查\N{\r原文字幕}and then the model checker will go through
Dialogue: 0,0:22:29.65,0:22:32.43,译文字幕,,0,0,0,,很快奥\N{\r原文字幕}and in you know a few nanoseconds
Dialogue: 0,0:22:32.65,0:22:37.59,译文字幕,,0,0,0,,对一些简单的我们检查一种可能的行为\N{\r原文字幕}for something that simple will we'll check whoa b1 possible
Dialogue: 0,0:22:37.60,0:22:42.45,译文字幕,,0,0,0,,你也可以写正式的正确性证明\N{\r原文字幕}their behavior and you can write formal correctness proofs
Dialogue: 0,0:22:42.58,0:22:44.76,译文字幕,,0,0,0,,然后在TLA+中做检查\N{\r原文字幕}and check them mechanically in TLA
Dialogue: 0,0:22:44.80,0:22:48.60,译文字幕,,0,0,0,,在TLA+中写证明\N{\r原文字幕}you know write the proofs in TLA plus
Dialogue: 0,0:22:48.37,0:22:51.69,译文字幕,,0,0,0,,然后我们有定理证明器来检查这些证明\N{\r原文字幕}and we have a theorem prover that can check the proofs
Dialogue: 0,0:22:51.43,0:22:56.61,译文字幕,,0,0,0,,这可老累了\N{\r原文字幕}and that's hard work and well all this is math stuff
Dialogue: 0,0:22:56.47,0:23:00.12,译文字幕,,0,0,0,,所有这些数学上得东西都非常完美\N{\r原文字幕}we know he's you know it's really very well nice and pretty stuff
Dialogue: 0,0:23:00.01,0:23:02.79,译文字幕,,0,0,0,,但数学的情况都非常理想\N{\r原文字幕}but we know that math works only for toy examples
Dialogue: 0,0:23:02.92,0:23:06.90,译文字幕,,0,0,0,,为了对真实的系统进行抽象，你需要一个真实的语言\N{\r原文字幕}to model real system you need a real language
Dialogue: 0,0:23:07.06,0:23:10.59,译文字幕,,0,0,0,,支持类型、构造器、对象等等\N{\r原文字幕}with types procedures objects and all of that
Dialogue: 0,0:23:10.47,0:23:19.53,译文字幕,,0,0,0,,开玩笑！我们来引用以为Amazon工程师的话\N{\r原文字幕}ma'am wrong let me quote something written by Chris Newcomb as an Amazon engineer
Dialogue: 0,0:23:20.16,0:23:26.55,译文字幕,,0,0,0,,“我们在10个线上项目上使用TLA+”\N{\r原文字幕}said we have used TL A+ on 10 large complex real-world systems
Dialogue: 0,0:23:26.92,0:23:31.68,译文字幕,,0,0,0,,“每个项目里TLA都展现了非凡的价值”\N{\r原文字幕}in every case TL A+ has added significant value
Dialogue: 0,0:23:31.62,0:23:37.56,译文字幕,,0,0,0,,“特别是在预防细微bug上”\N{\r原文字幕}either preventing subtle serious bugs from reaching production
Dialogue: 0,0:23:38.58,0:23:43.08,译文字幕,,0,0,0,,“这给了我们足够的信心”\N{\r原文字幕}or giving us enough understanding and confidence
Dialogue: 0,0:23:42.88,0:23:48.81,译文字幕,,0,0,0,,“去做更激进的性能优化而不用担心破坏正确性”\N{\r原文字幕}to make aggressive performance optimizations without sacrificing correctness
Dialogue: 0,0:23:48.87,0:23:52.95,译文字幕,,0,0,0,,人们总会告诉你使用正式的规范\N{\r原文字幕}one of the other things people will tell you about formal methods is
Dialogue: 0,0:23:52.63,0:23:55.65,译文字幕,,0,0,0,,会在性能上拖死你\N{\r原文字幕}oh if you use a formal method you're really going to kill your performance
Dialogue: 0,0:23:55.75,0:23:57.96,译文字幕,,0,0,0,,但是事实正相反\N{\r原文字幕}well in fact it's just the opposite
Dialogue: 0,0:23:58.32,0:24:02.85,译文字幕,,0,0,0,,他们还总说管理层不会允许的\N{\r原文字幕}and the other thing they'll tell you is Oh management will never let us do it
Dialogue: 0,0:24:02.65,0:24:08.82,译文字幕,,0,0,0,,但Amazon的管理层现在正鼓励团队使用TLA+\N{\r原文字幕}well management at Amazon and now encouraging teams to write TL a-plus specs
Dialogue: 0,0:24:09.21,0:24:16.33,译文字幕,,0,0,0,,他们在年度计划中规划使用TLA+的时间\N{\r原文字幕}and in annual planning managers are allocating engineering time to use TLA Plus
Dialogue: 0,0:24:17.11,0:24:21.31,译文字幕,,0,0,0,,这是在2013年写的\N{\r原文字幕}this was written in 2013 I think there are a few more systems
Dialogue: 0,0:24:21.23,0:24:23.41,译文字幕,,0,0,0,,应该还没有几个系统使用TLA+\N{\r原文字幕}that they've been specifying since then
Dialogue: 0,0:24:23.71,0:24:26.89,译文字幕,,0,0,0,,xbox360内存团队\N{\r原文字幕}the xbox360 memory system
Dialogue: 0,0:24:26.89,0:24:36.82,译文字幕,,0,0,0,,Chuck Thacker在Xbox内存系统的TLA plus spec有一个实习生\N{\r原文字幕}a Chuck Thacker had an intern right at TLA plus spec of the Xbox memory system
Dialogue: 0,0:24:36.74,0:24:41.98,译文字幕,,0,0,0,,仅仅写了规范但没有做模型检查\N{\r原文字幕}and just writing the spec didn't even get to point of model checking it
Dialogue: 0,0:24:41.87,0:24:49.09,译文字幕,,0,0,0,,他发现了一个bug\N{\r原文字幕}he caught a bug that the designers of the memory system at IBM
Dialogue: 0,0:24:49.13,0:24:53.17,译文字幕,,0,0,0,,一个IBM工程师抓破脑袋后承认的bug\N{\r原文字幕}after scratching their heads looking at it said yeah that was a bug
Dialogue: 0,0:24:52.97,0:24:57.01,译文字幕,,0,0,0,,一个没有被测试程序发现的bug\N{\r原文字幕}and that would not have been caught by their testing procedures
Dialogue: 0,0:24:57.08,0:25:03.91,译文字幕,,0,0,0,,这个bug将会引起世界上所有的xbox一起瘫痪\N{\r原文字幕}and that bug would have caused every Xbox in the world to crash after four hours of use
Dialogue: 0,0:25:05.26,0:25:08.38,译文字幕,,0,0,0,,你可以在web上学习TLA+\N{\r原文字幕}you can learn about TLA plus on the web
Dialogue: 0,0:25:08.62,0:25:12.22,译文字幕,,0,0,0,,今天我不教TLA+\N{\r原文字幕}today I'm not going to be talking about TLA plus
Dialogue: 0,0:25:11.99,0:25:14.50,译文字幕,,0,0,0,,我今天讲信息规范\N{\r原文字幕}I'm going to be talking about informal specifications
Dialogue: 0,0:25:14.87,0:25:16.96,译文字幕,,0,0,0,,来看个例子\N{\r原文字幕}and I'll start with an example
Dialogue: 0,0:25:18.52,0:25:22.63,译文字幕,,0,0,0,,TLA技术是TLA+的printer\N{\r原文字幕}TLA Tech which is the pretty printer for TL A+
Dialogue: 0,0:25:23.71,0:25:27.85,译文字幕,,0,0,0,,这可能是某个使用TLA+的人写的规范\N{\r原文字幕}here is what somebody user TL A+ user might write
Dialogue: 0,0:25:28.87,0:25:31.48,译文字幕,,0,0,0,,一些沙雕公式\N{\r原文字幕}some silly formula like this
Dialogue: 0,0:25:31.25,0:25:33.58,译文字幕,,0,0,0,,如果在此基础上做些微小的工作\N{\r原文字幕}and if you just did the naive output
Dialogue: 0,0:25:33.62,0:25:42.67,译文字幕,,0,0,0,,选一些字体，然后翻译成ASCII\N{\r原文字幕}just took things from teletype font and put them into translated the ascii into the symbols
Dialogue: 0,0:25:42.62,0:25:45.67,译文字幕,,0,0,0,,把/\转换成^\N{\r原文字幕}left / right / into the conjunction symbol
Dialogue: 0,0:25:45.62,0:25:50.14,译文字幕,,0,0,0,,就变成了右边的公式\N{\r原文字幕}and you get something like that formula and the right
Dialogue: 0,0:25:50.35,0:25:56.38,译文字幕,,0,0,0,,对齐在TLA+中非常重要\N{\r原文字幕}but alignment is actually has significance in TL a-plus
Dialogue: 0,0:25:56.50,0:26:03.76,译文字幕,,0,0,0,,没人喜欢右边的对齐方式\N{\r原文字幕}and the user undoubtedly wanted he certainly wanted the left conjunction symbols aligned
Dialogue: 0,0:26:03.62,0:26:06.64,译文字幕,,0,0,0,,因为可能有歧义\N{\r原文字幕}because the formula might mean something different otherwise
Dialogue: 0,0:26:06.68,0:26:09.73,译文字幕,,0,0,0,,并且人们确实希望等号是对齐的\N{\r原文字幕}and he also probably wanted those equal signs aligned
Dialogue: 0,0:26:10.81,0:26:15.97,译文字幕,,0,0,0,,所以这是一个正面例子\N{\r原文字幕}so this is the right output that the pretty partition produce for this example
Dialogue: 0,0:26:16.39,0:26:19.12,译文字幕,,0,0,0,,请看这个例子\N{\r原文字幕}on the other hand if you look at this input
Dialogue: 0,0:26:19.48,0:26:22.72,译文字幕,,0,0,0,,它的naive格式为\N{\r原文字幕}this is what the naive output would be like
Dialogue: 0,0:26:22.55,0:26:27.16,译文字幕,,0,0,0,,这两种都没人喜欢\N{\r原文字幕}and the user probably didn't want those two symbols aligned
Dialogue: 0,0:26:27.20,0:26:29.17,译文字幕,,0,0,0,,oh 完蛋\N{\r原文字幕}that was probably just an accidental
Dialogue: 0,0:26:30.05,0:26:35.20,译文字幕,,0,0,0,,所以在这个例子中，右边的正确\N{\r原文字幕}so in this case the naive output is the correct output that's what you want
Dialogue: 0,0:26:35.53,0:26:40.54,译文字幕,,0,0,0,,也就是说我们对对齐这件事没有准确的定义\N{\r原文字幕}well there's no precise definition of correct alignment
Dialogue: 0,0:26:40.76,0:26:43.24,译文字幕,,0,0,0,,准确的定义有用户决定\N{\r原文字幕}correctness means what the user wants
Dialogue: 0,0:26:43.10,0:26:46.57,译文字幕,,0,0,0,,要用户来确定的事那就是不确定\N{\r原文字幕}and there's no way of formally specifying what the user wants
Dialogue: 0,0:26:48.07,0:26:53.01,译文字幕,,0,0,0,,所以很明显 如果我们可以指定正确性规范\N{\r原文字幕}so obviously if we can specify correctness specification
Dialogue: 0,0:26:53.51,0:26:56.23,译文字幕,,0,0,0,,我们需要什么样的规范才能说明正确性\N{\r原文字幕}what good can specification we need to specify correctness
Dialogue: 0,0:26:56.27,0:26:57.94,译文字幕,,0,0,0,,我们如何使用规范\N{\r原文字幕}what could how can we use specification
Dialogue: 0,0:26:58.30,0:27:00.16,译文字幕,,0,0,0,,是的我们可以\N{\r原文字幕}well we can
Dialogue: 0,0:27:00.88,0:27:07.39,译文字幕,,0,0,0,,不知道一个程序应该做什么并不意味着你不必思考\N{\r原文字幕}not knowing what a program should do doesn't mean you don't have to think you just do this code
Dialogue: 0,0:27:07.19,0:27:09.88,译文字幕,,0,0,0,,它意味着你要多想\N{\r原文字幕}it means you have to think a lot harder
Dialogue: 0,0:27:11.38,0:27:16.00,译文字幕,,0,0,0,,也就是说规范在你不知道code是干啥时\N{\r原文字幕}which means that that's what a spec is even more important
Dialogue: 0,0:27:16.10,0:27:19.45,译文字幕,,0,0,0,,更为重要\N{\r原文字幕}when you don't know what the program is supposed to do
Dialogue: 0,0:27:19.13,0:27:22.78,译文字幕,,0,0,0,,规范描述了code应该做什么\N{\r原文字幕}and it seems impossible to even say what it should do
Dialogue: 0,0:27:22.52,0:27:26.20,译文字幕,,0,0,0,,因为你要决定code应该做什么\N{\r原文字幕}because it has to do something and you have to decide what it should do
Dialogue: 0,0:27:25.88,0:27:28.84,译文字幕,,0,0,0,,所以你要多想，多写\N{\r原文字幕}so that requires a lot of thinking which requires writing
Dialogue: 0,0:27:29.29,0:27:31.75,译文字幕,,0,0,0,,我就是这样做的\N{\r原文字幕}so what did I do
Dialogue: 0,0:27:32.41,0:27:38.05,译文字幕,,0,0,0,,我的规范有6条规则\N{\r原文字幕}well my spec consisted of six rules plus definitions
Dialogue: 0,0:27:38.36,0:27:43.90,译文字幕,,0,0,0,,他们是带信息的数学片段\N{\r原文字幕}and these are in informal met you know quote mathematical prose
Dialogue: 0,0:27:43.64,0:27:45.91,译文字幕,,0,0,0,,他们在注释中\N{\r原文字幕}and formal if they're written in comments
Dialogue: 0,0:27:45.89,0:27:48.49,译文字幕,,0,0,0,,来看其中一条\N{\r原文字幕}oh here's an example of one of the rules
Dialogue: 0,0:27:48.20,0:27:53.71,译文字幕,,0,0,0,,它说左注释标记是与其覆盖标记对齐的左注释\N{\r原文字幕}it says a left comment token is left comment aligned with its covering token
Dialogue: 0,0:27:53.60,0:27:56.62,译文字幕,,0,0,0,,lamport也不知道这rule干啥的\N{\r原文字幕}well I don't even know what that means anymore
Dialogue: 0,0:27:56.27,0:27:58.09,译文字幕,,0,0,0,,我得看看说明书\N{\r原文字幕}I'd have to read the spec
Dialogue: 0,0:27:57.86,0:28:01.57,译文字幕,,0,0,0,,但是左注释对齐和覆盖标记是术语\N{\r原文字幕}but left comment aligned and covering token are terms
Dialogue: 0,0:28:01.46,0:28:07.09,译文字幕,,0,0,0,,在我编写的本规范中定义的\N{\r原文字幕}that were defined in the in this specification I wrote
Dialogue: 0,0:28:06.80,0:28:12.10,译文字幕,,0,0,0,,如果你看它 这是真正的数学散文\N{\r原文字幕}and if you look at it this is really mathematical prose
Dialogue: 0,0:28:13.18,0:28:22.24,译文字幕,,0,0,0,,我写了什么这个规范 它更容易理解和调试六个规则\N{\r原文字幕}what did I write this spec well it was a lot easier to understand and debug six rules
Dialogue: 0,0:28:22.30,0:28:28.75,译文字幕,,0,0,0,,超过850行的代码 也可能超过850行\N{\r原文字幕}than 850 lines of code probably would have been more than 850 lines of code
Dialogue: 0,0:28:28.46,0:28:30.13,译文字幕,,0,0,0,,如果不是我先写了这些规则\N{\r原文字幕}if I hadn't written those rules first
Dialogue: 0,0:28:30.19,0:28:33.04,译文字幕,,0,0,0,,我对规则做了很多调试\N{\r原文字幕}and I did a lot of debugging of the rules
Dialogue: 0,0:28:33.73,0:28:36.79,译文字幕,,0,0,0,,你写了一堆规则\N{\r原文字幕}you know you write a bunch of rules
Dialogue: 0,0:28:36.56,0:28:39.13,译文字幕,,0,0,0,,但是他们是干啥的并不明显\N{\r原文字幕}and you know what they're going to do is not obvious
Dialogue: 0,0:28:39.20,0:28:44.32,译文字幕,,0,0,0,,你试了一堆例子 试了一个调试代码\N{\r原文字幕}and you try a bunch of examples and I a debugging code
Dialogue: 0,0:28:44.18,0:28:46.90,译文字幕,,0,0,0,,这样我就可以看到应用了什么规则\N{\r原文字幕}so I could see what rules were being applied
Dialogue: 0,0:28:46.70,0:28:52.21,译文字幕,,0,0,0,,我们不会做一些奇怪的事情 然后说 这条规则需要修改\N{\r原文字幕}and we don't would do with something weird and I say oh and that rule needs to be modified
Dialogue: 0,0:28:52.16,0:28:54.79,译文字幕,,0,0,0,,对于这个迭代过程\N{\r原文字幕}for this and an iterative process
Dialogue: 0,0:28:54.59,0:29:01.03,译文字幕,,0,0,0,,少数的错误和规则的实现很容易被发现\N{\r原文字幕}and the few bugs and implementing the rules were easy to catch
Dialogue: 0,0:29:00.74,0:29:02.35,译文字幕,,0,0,0,,虽然没有问题\N{\r原文字幕}though there was no problem
Dialogue: 0,0:29:03.10,0:29:05.56,译文字幕,,0,0,0,,如果我刚写了代码\N{\r原文字幕}had I just written the code
Dialogue: 0,0:29:05.33,0:29:11.11,译文字幕,,0,0,0,,我要花更长的时间才能找到我能忍受的东西\N{\r原文字幕}it would have taken me much longer to just get something I could live with
Dialogue: 0,0:29:10.85,0:29:15.64,译文字幕,,0,0,0,,我确信结果不会产生如此好的格式\N{\r原文字幕}and I'm sure the results wouldn't have produced formatting nearly as good
Dialogue: 0,0:29:16.12,0:29:20.17,译文字幕,,0,0,0,,那么为什么不是一个正式的规范呢 为什么我不在TLA+spec上写呢\N{\r原文字幕}so why not a formal spec why didn't I write at TLA + spec
Dialogue: 0,0:29:20.08,0:29:22.24,译文字幕,,0,0,0,,几个原因\N{\r原文字幕}well several reasons
Dialogue: 0,0:29:22.13,0:29:24.52,译文字幕,,0,0,0,,首先 并不一定需要格式\N{\r原文字幕}first of all getting it right was not that important
Dialogue: 0,0:29:24.56,0:29:26.74,译文字幕,,0,0,0,,世界不会因为\N{\r原文字幕}the world is not going to come crashing
Dialogue: 0,0:29:26.75,0:29:30.31,译文字幕,,0,0,0,,有些东西没有很好地对齐和漂亮的打印而崩溃\N{\r原文字幕}down if something isn't quite properly aligned and pretty printing
Dialogue: 0,0:29:30.61,0:29:34.33,译文字幕,,0,0,0,,特别是 它也不一定在所有情况下都漂亮\N{\r原文字幕}in particular it didn't have to work in all corner cases
Dialogue: 0,0:29:34.04,0:29:37.81,译文字幕,,0,0,0,,没有一条路是完全正确的\N{\r原文字幕}yes No you know there's no way of getting it you know totally right
Dialogue: 0,0:29:37.72,0:29:42.04,译文字幕,,0,0,0,,重要的是没有任何工具\N{\r原文字幕}and just as important there aren't any tools
Dialogue: 0,0:29:41.99,0:29:45.73,译文字幕,,0,0,0,,可以帮助我，模型检查器在这个例子中没有帮助\N{\r原文字幕}that could help me the model checker wouldn't have helped in this example
Dialogue: 0,0:29:45.68,0:29:49.96,译文字幕,,0,0,0,,因为你需要一些属性来检查它\N{\r原文字幕}because you know you need some some properties to check it against
Dialogue: 0,0:29:49.91,0:29:54.91,译文字幕,,0,0,0,,他们只是工具\N{\r原文字幕}and you know they're just tools were not
Dialogue: 0,0:29:54.62,0:29:59.71,译文字幕,,0,0,0,,TLA plus工具不是为这类问题而设计的\N{\r原文字幕}you know the TLA plus tools are not designed for that kind of problems
Dialogue: 0,0:29:59.66,0:30:02.17,译文字幕,,0,0,0,,那么这个规范的典型特征是什么\N{\r原文字幕}so what's typical about this spec
Dialogue: 0,0:30:02.23,0:30:05.95,译文字幕,,0,0,0,,规范在代码之上\N{\r原文字幕}the spec is at a higher level than the code
Dialogue: 0,0:30:06.07,0:30:09.25,译文字幕,,0,0,0,,规范可被任何语言实现\N{\r原文字幕}it could have been implemented in any language
Dialogue: 0,0:30:10.57,0:30:17.62,译文字幕,,0,0,0,,没有方法也没有工具没有你最喜欢的编程方法\N{\r原文字幕}no method nor tool none of your favorite ways of you know programming methodologies
Dialogue: 0,0:30:18.22,0:30:21.19,译文字幕,,0,0,0,,在这里一文不值\N{\r原文字幕}would have been worth a damn here
Dialogue: 0,0:30:21.17,0:30:24.10,译文字幕,,0,0,0,,对写规范的一点帮助都没有\N{\r原文字幕}they would not have helped me write the spec
Dialogue: 0,0:30:24.67,0:30:31.42,译文字幕,,0,0,0,,因为不论是什么方法\N{\r原文字幕}because no method of writing you know better code
Dialogue: 0,0:30:31.28,0:30:33.34,译文字幕,,0,0,0,,规范都同样重要\N{\r原文字幕}would have made the spec unnecessary
Dialogue: 0,0:30:33.80,0:30:37.54,译文字幕,,0,0,0,,我得写规范而不是code\N{\r原文字幕}I had to write the spec it was not code
Dialogue: 0,0:30:37.45,0:30:45.46,译文字幕,,0,0,0,,规范可没说你怎么实现\N{\r原文字幕}and it says nothing about how to write the code you could implement my spec in any language
Dialogue: 0,0:30:45.50,0:30:53.47,译文字幕,,0,0,0,,写规范是帮助你思考\N{\r原文字幕}you write a spec to help you think about the problem before you think about the code
Dialogue: 0,0:30:54.62,0:30:57.44,译文字幕,,0,0,0,,那么这个规范的不典型之处是什么呢\N{\r原文字幕}so what's not typical about this spec
Dialogue: 0,0:30:57.45,0:30:58.85,译文字幕,,0,0,0,,写的含糊不清\N{\r原文字幕}it's quite subtle
Dialogue: 0,0:30:59.01,0:31:04.55,译文字幕,,0,0,0,,记得我说过95%的代码只需要更少的思考\N{\r原文字幕}remember I said 95% of code people write requires less thought
Dialogue: 0,0:31:04.38,0:31:08.06,译文字幕,,0,0,0,,更简单更短的规格足够好了\N{\r原文字幕}and you know simpler shorter specs good enough
Dialogue: 0,0:31:08.33,0:31:10.43,译文字幕,,0,0,0,,直接写一套规则\N{\r原文字幕}also it's a set of rules
Dialogue: 0,0:31:10.17,0:31:15.44,译文字幕,,0,0,0,,一组规则 需求或公理通常是一个糟糕的规范\N{\r原文字幕}a set of rules or requirements or axioms is usually a bad spec
Dialogue: 0,0:31:15.39,0:31:17.48,译文字幕,,0,0,0,,因为这真的很难理解\N{\r原文字幕}because it's really hard to understand
Dialogue: 0,0:31:17.55,0:31:21.68,译文字幕,,0,0,0,,事实上，它很好的解释了特殊问题\N{\r原文字幕}it turns out that that was a good match for this particular problem
Dialogue: 0,0:31:21.66,0:31:28.01,译文字幕,,0,0,0,,这意味着没有关于如何编写规范的通用规则\N{\r原文字幕}which says there are no universal rules about how to write specs
Dialogue: 0,0:31:30.33,0:31:34.76,译文字幕,,0,0,0,,没有万能的规则可以告诉你如何编写任何程序\N{\r原文字幕}no universal rules that'll tell you how to write any program in the world
Dialogue: 0,0:31:35.12,0:31:38.21,译文字幕,,0,0,0,,那么定义怎么去计算一个函数\N{\r原文字幕}so specifying how to compute a function
Dialogue: 0,0:31:39.53,0:31:42.44,译文字幕,,0,0,0,,定义怎么打印是难得\N{\r原文字幕}specifying what the pretty printer should do is hard
Dialogue: 0,0:31:43.73,0:31:45.83,译文字幕,,0,0,0,,实现规范是容易的\N{\r原文字幕}implementing the spec was easy
Dialogue: 0,0:31:47.57,0:31:51.05,译文字幕,,0,0,0,,定义一个排序程序是简单地\N{\r原文字幕}specifying what a sorting program should do is easy
Dialogue: 0,0:31:51.50,0:31:55.28,译文字幕,,0,0,0,,弄清楚如何有效地实现它是很困难的\N{\r原文字幕}figuring out how to implement it efficiently is hard
Dialogue: 0,0:31:55.11,0:31:57.20,译文字幕,,0,0,0,,没人告诉你咋整\N{\r原文字幕}at least if nobody has showed you how
Dialogue: 0,0:31:58.46,0:32:03.11,译文字幕,,0,0,0,,这需要你思考，需要写规范\N{\r原文字幕}it requires thinking which requires writing a specification
Dialogue: 0,0:32:03.77,0:32:07.94,译文字幕,,0,0,0,,来看快排的规范\N{\r原文字幕}so I'll give you an example of a specification for quicksort
Dialogue: 0,0:32:09.38,0:32:11.36,译文字幕,,0,0,0,,大家都知道快排\N{\r原文字幕}probably you all seen quicksort
Dialogue: 0,0:32:11.37,0:32:15.71,译文字幕,,0,0,0,,快排是典型的减而治之算法\N{\r原文字幕}quicksort is written by Tony Hoare it's a divide-and-conquer algorithm
Dialogue: 0,0:32:15.75,0:32:16.88,译文字幕,,0,0,0,,为了排序一个数组\N{\r原文字幕}for sorting an array
Dialogue: 0,0:32:16.65,0:32:19.88,译文字幕,,0,0,0,,从A[0]到A[n-1]\N{\r原文字幕}call it a zero to a n minus one
Dialogue: 0,0:32:19.59,0:32:22.61,译文字幕,,0,0,0,,简单起见，A是一个number数组\N{\r原文字幕}and for simplicity I'll assume that's an array of numbers
Dialogue: 0,0:32:22.64,0:32:27.92,译文字幕,,0,0,0,,快排使用partition进程，来从lo到hi-1之间\N{\r原文字幕}and it uses a partition procedure you give it two arguments low and high
Dialogue: 0,0:32:27.57,0:32:33.26,译文字幕,,0,0,0,,选择一个pivot point\N{\r原文字幕}and what that procedure does is it chooses a pivot point
Dialogue: 0,0:32:32.84,0:32:36.29,原文字幕,,0,0,0,,pivot number in low to high minus 1
Dialogue: 0,0:32:36.03,0:32:42.26,译文字幕,,0,0,0,,然后交换A[lo]和A[hi]\N{\r原文字幕}and then it permutes the elements to the left of the pivot a low to a high
Dialogue: 0,0:32:43.70,0:32:52.10,译文字幕,,0,0,0,,使得\N{\r原文字幕}it permutes the number the the part of the array within the limit from low to high
Dialogue: 0,0:32:52.19,0:32:56.15,译文字幕,,0,0,0,,所有轴点左边小于等于轴点\N{\r原文字幕}so that everything from pivot downwards
Dialogue: 0,0:32:56.49,0:33:00.68,原文字幕,,0,0,0,,is becomes is less than or equal to
Dialogue: 0,0:33:00.69,0:33:03.08,译文字幕,,0,0,0,,所有轴点右边大于轴点\N{\r原文字幕}everything from pivot plus 1 upwards
Dialogue: 0,0:33:04.19,0:33:08.00,译文字幕,,0,0,0,,得益于我们都知道快排\N{\r原文字幕}so fortunately if well seen quick sort before
Dialogue: 0,0:33:07.92,0:33:11.75,译文字幕,,0,0,0,,所以导播掐一下这段快排的描述\N{\r原文字幕}so i rambling description isn't necessary
Dialogue: 0,0:33:12.11,0:33:17.00,译文字幕,,0,0,0,,说重点，我不关心怎么实现\N{\r原文字幕}and for this example I don't care how this procedure is implemented
Dialogue: 0,0:33:17.01,0:33:19.91,译文字幕,,0,0,0,,当然 怎么实现是快排的核心\N{\r原文字幕}of course that's the real trick of quicksort implementing
Dialogue: 0,0:33:20.01,0:33:23.96,译文字幕,,0,0,0,,但我只有50min\N{\r原文字幕}that but you know I only have 50 minutes here so
Dialogue: 0,0:33:23.93,0:33:26.57,译文字幕,,0,0,0,,所以我们用伪代码来描述快排\N{\r原文字幕}so let's specify quicksort and pseudocode
Dialogue: 0,0:33:27.26,0:33:33.29,译文字幕,,0,0,0,,看图\N{\r原文字幕}you know this by the partition procedure is pick a pivot and low-to-high -1 and
Dialogue: 0,0:33:33.09,0:33:35.39,原文字幕,,0,0,0,,permute a low to a high to make bla bla
Dialogue: 0,0:33:35.40,0:33:37.40,原文字幕,,0,0,0,,bla and return the value pivot
Dialogue: 0,0:33:38.15,0:33:43.67,译文字幕,,0,0,0,,然后递归之\N{\r原文字幕}and you have a recursive procedure q s applied to low to high
Dialogue: 0,0:33:43.68,0:33:45.71,原文字幕,,0,0,0,,and if low is less than high
Dialogue: 0,0:33:45.71,0:33:50.99,原文字幕,,0,0,0,,you call the protection procedure for on low and high
Dialogue: 0,0:33:50.64,0:33:56.26,原文字幕,,0,0,0,,and then you recursively call the procedure for the 2 subintervals
Dialogue: 0,0:33:57.68,0:34:03.83,原文字幕,,0,0,0,,and if low is not less than high then it means you have one element
Dialogue: 0,0:34:03.89,0:34:07.58,原文字幕,,0,0,0,,and there's nothing to sort and so you're done
Dialogue: 0,0:34:07.26,0:34:14.15,原文字幕,,0,0,0,,and the main program just implies QS to the entire array from Sirte and minus one
Dialogue: 0,0:34:14.30,0:34:21.29,译文字幕,,0,0,0,,没有那些繁琐的东西\N{\r原文字幕}so informal no formal syntax no declarations pseudocode
Dialogue: 0,0:34:21.57,0:34:25.55,译文字幕,,0,0,0,,伪代码是一种很好的规范\N{\r原文字幕}it's it's a fine specification yeah when
Dialogue: 0,0:34:25.14,0:34:28.04,译文字幕,,0,0,0,,你可以根据伪代码写好code\N{\r原文字幕}you're gonna code you know pretty trivial to code from this
Dialogue: 0,0:34:27.69,0:34:29.84,译文字幕,,0,0,0,,用任何语言\N{\r原文字幕}and you know any programming language
Dialogue: 0,0:34:30.11,0:34:31.82,译文字幕,,0,0,0,,都行\N{\r原文字幕}easy to understand
Dialogue: 0,0:34:32.48,0:34:34.67,译文字幕,,0,0,0,,但这真的够快么\N{\r原文字幕}but it's a really quick sort
Dialogue: 0,0:34:35.39,0:34:38.48,译文字幕,,0,0,0,,这是快排的平凡描述\N{\r原文字幕}it's the way quicksort is almost always described
Dialogue: 0,0:34:39.71,0:34:44.18,译文字幕,,0,0,0,,但是递归可不是快排的必要部分\N{\r原文字幕}but recursion is not a form fundamental part of quicksort
Dialogue: 0,0:34:44.33,0:34:48.32,译文字幕,,0,0,0,,减而治之只有一种实现方式\N{\r原文字幕}it's just one way of implementing divide and conquer
Dialogue: 0,0:34:48.21,0:34:50.09,译文字幕,,0,0,0,,这就有问题了\N{\r原文字幕}now here's a problem
Dialogue: 0,0:34:49.83,0:34:52.79,译文字幕,,0,0,0,,事实上，递归不是最好的方式\N{\r原文字幕}and in fact it's probably not the best way
Dialogue: 0,0:34:52.74,0:34:56.87,译文字幕,,0,0,0,,如果你在多个核心上使用该算法\N{\r原文字幕}if you want to execute this on multiple cores
Dialogue: 0,0:34:56.96,0:35:00.59,译文字幕,,0,0,0,,留个作业\N{\r原文字幕}so here's a problem give to your friends and colleagues
Dialogue: 0,0:35:00.35,0:35:04.07,译文字幕,,0,0,0,,写一个非递归形式的快排\N{\r原文字幕}write a non recursive version of quicksort
Dialogue: 0,0:35:05.06,0:35:07.76,译文字幕,,0,0,0,,好像没人可以在10分钟内写出来\N{\r原文字幕}almost no one can do it in ten minutes
Dialogue: 0,0:35:07.79,0:35:11.21,译文字幕,,0,0,0,,受递归版本的影响\N{\r原文字幕}they try to compile the recursive version
Dialogue: 0,0:35:11.16,0:35:12.53,译文字幕,,0,0,0,,没人可以\N{\r原文字幕}and nobody can get
Dialogue: 0,0:35:12.18,0:35:15.74,译文字幕,,0,0,0,,没人可以在10分钟内写出来\N{\r原文字幕}almost nobody can get that right and ten minutes standing on their feet
Dialogue: 0,0:35:16.46,0:35:20.06,译文字幕,,0,0,0,,我来告诉你正确的方法\N{\r原文字幕}but I'll tell you you know what the real solution is
Dialogue: 0,0:35:21.12,0:35:25.04,译文字幕,,0,0,0,,我们要做的是维护一个带索引的集合U\N{\r原文字幕}we do is maintain a set u of index ranges
Dialogue: 0,0:35:25.05,0:35:27.89,译文字幕,,0,0,0,,partition作用于这个集合\N{\r原文字幕}on which partition needs to be called
Dialogue: 0,0:35:28.55,0:35:35.09,译文字幕,,0,0,0,,U的初始状态是整个待排数组的范围（0到n-1）\N{\r原文字幕}initially u equals contain is a set containing a single index range
Dialogue: 0,0:35:34.80,0:35:37.52,译文字幕,,0,0,0,,从0到N-1\N{\r原文字幕}from zero and minus one represented by this pair
Dialogue: 0,0:35:37.91,0:35:40.34,译文字幕,,0,0,0,,现在我们写伪代码\N{\r原文字幕}now we can write this in pseudocode
Dialogue: 0,0:35:40.74,0:35:47.15,译文字幕,,0,0,0,,但是想想科学家怎么做，让我们写下初态和步进公式\N{\r原文字幕}but let's be scientists let's write init and next directly in mathematics
Dialogue: 0,0:35:47.63,0:35:49.70,译文字幕,,0,0,0,,所以有如下假设\N{\r原文字幕}so the initial predicate
Dialogue: 0,0:35:50.27,0:35:54.74,译文字幕,,0,0,0,,设A是长度为N的number数组\N{\r原文字幕}says a is equal to any array of numbers of length n
Dialogue: 0,0:35:54.48,0:35:59.57,译文字幕,,0,0,0,,U是一些元素的集合\N{\r原文字幕}and u is equal to the set consisting of that single element
Dialogue: 0,0:35:59.96,0:36:05.60,译文字幕,,0,0,0,,在数学上这不够正式\N{\r原文字幕}yep this is in formal mathematics but it's informal you know
Dialogue: 0,0:36:05.22,0:36:12.08,译文字幕,,0,0,0,,我们可以正式点\N{\r原文字幕}we could write some formal way of describing the set of a on any array of numbers of length N
Dialogue: 0,0:36:12.05,0:36:15.11,译文字幕,,0,0,0,,在写步进前做一些定义\N{\r原文字幕}and before writing next let me make a definition
Dialogue: 0,0:36:16.10,0:36:20.03,译文字幕,,0,0,0,,定义Partitions(B,pivot,lo,hi)\N{\r原文字幕}let me define partitions of B pivot low high
Dialogue: 0,0:36:20.09,0:36:23.93,译文字幕,,0,0,0,,参数表示B的一个子集\N{\r原文字幕}it's the set of arrays obtained from B
Dialogue: 0,0:36:24.26,0:36:27.83,译文字幕,,0,0,0,,即B[lo] 到B[hi]\N{\r原文字幕}by permuting the load to be high
Dialogue: 0,0:36:27.86,0:36:31.49,译文字幕,,0,0,0,,使用pivot分区\N{\r原文字幕}with pivot point pivot in other words
Dialogue: 0,0:36:31.23,0:36:34.91,译文字幕,,0,0,0,,即partition程序作用的集合\N{\r原文字幕}it's the set of all values that the partition procedure
Dialogue: 0,0:36:34.67,0:36:38.09,译文字幕,,0,0,0,,Patition函数在这个子集中\N{\r原文字幕}the set of all new values of a that
Dialogue: 0,0:36:38.13,0:36:40.19,译文字幕,,0,0,0,,找轴点并且返回\N{\r原文字幕}the partition procedure is allowed to return
Dialogue: 0,0:36:40.62,0:36:44.54,译文字幕,,0,0,0,,在如果需要返回轴点的情况\N{\r原文字幕}if it's also returning pivot as the pivot point
Dialogue: 0,0:36:44.28,0:36:46.91,译文字幕,,0,0,0,,简单起见我就不写了\N{\r原文字幕}and I won't bother writing it out precisely
Dialogue: 0,0:36:48.26,0:36:54.29,译文字幕,,0,0,0,,所以步进关系表示的事U的旧值到新值的关系\N{\r原文字幕}so next remember it's going to be a relation between the old values of a of U
Dialogue: 0,0:36:54.00,0:36:56.81,译文字幕,,0,0,0,,新值带撇\N{\r原文字幕}and the new values a prime and u Prime
Dialogue: 0,0:36:56.81,0:36:58.73,译文字幕,,0,0,0,,我们试着写一下\N{\r原文字幕}so let's write it
Dialogue: 0,0:36:58.85,0:37:01.88,译文字幕,,0,0,0,,首先，如果是空集\N{\r原文字幕}first of all we're gonna stop
Dialogue: 0,0:37:01.86,0:37:03.53,译文字幕,,0,0,0,,我们应该stop\N{\r原文字幕}if u is the empty set
Dialogue: 0,0:37:03.35,0:37:08.15,译文字幕,,0,0,0,,所以步进关系说，U应该不是空的\N{\r原文字幕}so the next state relation says U is not equal to the empty set
Dialogue: 0,0:37:08.04,0:37:12.50,译文字幕,,0,0,0,,看图\N{\r原文字幕}and so performing there's going to be false if u is the empty set
Dialogue: 0,0:37:13.01,0:37:19.88,译文字幕,,0,0,0,,然后我们选择U中的任意一对B T 如果B\N{\r原文字幕}then we pick any pair BT in U and if B
Dialogue: 0,0:37:19.89,0:37:28.58,译文字幕,,0,0,0,,不等于T,那么我们选择B中的任意点P,任意数P\N{\r原文字幕}is not equal to T then we pick any point P any number P lying in B to t minus 1
Dialogue: 0,0:37:28.32,0:37:33.95,译文字幕,,0,0,0,,我们让旧值是\N{\r原文字幕}and we let a prime be any element of
Dialogue: 0,0:37:34.67,0:37:37.33,译文字幕,,0,0,0,,通过Partition得到的合法分区\N{\r原文字幕}the set of legal partitions you know the
Dialogue: 0,0:37:37.34,0:37:40.41,译文字幕,,0,0,0,,一组合法分区中的任意值\N{\r原文字幕}results of the partition function that
Dialogue: 0,0:37:40.91,0:37:43.54,译文字幕,,0,0,0,,如果你把b和t当做输入\N{\r原文字幕}if you've given it B and T as the input
Dialogue: 0,0:37:43.55,0:37:48.43,译文字幕,,0,0,0,,返回轴点p\N{\r原文字幕}and it returns P as the partition as the
Dialogue: 0,0:37:48.44,0:37:54.52,原文字幕,,0,0,0,,pivot point and then u prime is a set u
Dialogue: 0,0:37:54.53,0:37:57.58,译文字幕,,0,0,0,,我们完成剩余的元素bT\N{\r原文字幕}we're finished with the remain element bT
Dialogue: 0,0:37:57.50,0:38:00.79,译文字幕,,0,0,0,,所以我们把它从集合中移开 然后加上2个子区间\N{\r原文字幕}so we move that from the set and then we add the 2 subintervals
Dialogue: 0,0:38:01.30,0:38:05.32,原文字幕,,0,0,0,,B P and you know to be and P plus 1 to T
Dialogue: 0,0:38:05.06,0:38:12.13,原文字幕,,0,0,0,,into the set u of of ranges that still need to be sorted
Dialogue: 0,0:38:13.18,0:38:18.55,原文字幕,,0,0,0,,otherwise if B is not e is equal to T then there's nothing to do
Dialogue: 0,0:38:18.23,0:38:26.62,原文字幕,,0,0,0,,we leave a prime unchanged and we let u prime equal u with BT removed
Dialogue: 0,0:38:26.57,0:38:29.44,原文字幕,,0,0,0,,we just take BT out of out of the set
Dialogue: 0,0:38:29.18,0:38:32.62,原文字幕,,0,0,0,,and that's the next state relation
Dialogue: 0,0:38:32.83,0:38:40.98,译文字幕,,0,0,0,,这就是快排的迭代版本\N{\r原文字幕}that describes a very nice way of doing quicksort iterative iteratively
Dialogue: 0,0:38:41.48,0:38:45.91,译文字幕,,0,0,0,,这实际上是跟平凡的实现\N{\r原文字幕}it's actually a more general algorithm because if you
Dialogue: 0,0:38:45.50,0:38:47.50,译文字幕,,0,0,0,,你看整个执行过程\N{\r原文字幕}look at all the behaviors that can produce
Dialogue: 0,0:38:48.01,0:38:53.47,译文字幕,,0,0,0,,递归只是子集\N{\r原文字幕}the set of behaviors produced by the recursive version is a sub set
Dialogue: 0,0:38:53.27,0:38:56.86,译文字幕,,0,0,0,,这是所有值序列的集合\N{\r原文字幕}that is the set of all sequences of values
Dialogue: 0,0:38:56.81,0:38:59.47,译文字幕,,0,0,0,,假设它是一个子集\N{\r原文字幕}that a assumes is going to be a subset
Dialogue: 0,0:38:59.51,0:39:06.34,译文字幕,,0,0,0,,下一个状态关系所允许的\N{\r原文字幕}of the ones that this next state relation allows
Dialogue: 0,0:39:06.67,0:39:10.99,译文字幕,,0,0,0,,所以为什么几乎没人发现这个版本呢\N{\r原文字幕}so why can almost no one find this version of quicksort
Dialogue: 0,0:39:12.22,0:39:15.67,译文字幕,,0,0,0,,因为人们的思维陷在code里\N{\r原文字幕}because people's minds are stuck in code
Dialogue: 0,0:39:16.30,0:39:23.20,译文字幕,,0,0,0,,没有在code之上思考code\N{\r原文字幕}they haven't thought learn to think at a higher level than the code
Dialogue: 0,0:39:23.59,0:39:27.28,译文字幕,,0,0,0,,现在可以很容易的写出准确公式\N{\r原文字幕}now it's easy to write this as a precise formula
Dialogue: 0,0:39:27.58,0:39:33.10,原文字幕,,0,0,0,,pick any arbitrary value is really existential quantification
Dialogue: 0,0:39:33.17,0:39:40.30,原文字幕,,0,0,0,,the formula is true if there exists a value B T and u similarly there
Dialogue: 0,0:39:40.13,0:39:46.75,原文字幕,,0,0,0,,and just let letting a prime be any element of this set
Dialogue: 0,0:39:46.52,0:39:48.16,译文字幕,,0,0,0,,现在足够简单了\N{\r原文字幕}well that's easy enough to write
Dialogue: 0,0:39:48.08,0:39:50.29,原文字幕,,0,0,0,,is a prime and an element of that
Dialogue: 0,0:39:50.24,0:39:54.40,原文字幕,,0,0,0,,and those relations new values of U prime those thinks the
Dialogue: 0,0:39:54.22,0:39:58.09,原文字幕,,0,0,0,,with prose to the right of the equal sign
Dialogue: 0,0:39:57.91,0:39:59.89,原文字幕,,0,0,0,,they're easy to express
Dialogue: 0,0:40:00.13,0:40:09.67,原文字幕,,0,0,0,,whoops this way and so on then
Dialogue: 0,0:40:09.88,0:40:19.09,译文字幕,,0,0,0,, 现在你有一个完美的TLA+公式\N{\r原文字幕}so what you have is a TLA plus formula here perfectly formal
Dialogue: 0,0:40:19.54,0:40:22.27,译文字幕,,0,0,0,,如果你还是喜欢伪代码\N{\r原文字幕}if you prefer pseudocode
Dialogue: 0,0:40:23.77,0:40:28.63,译文字幕,,0,0,0,,我们也有Plus cal， 它想一种玩具语言\N{\r原文字幕}we have plus Cal it looks like a toy programming language
Dialogue: 0,0:40:28.55,0:40:34.84,译文字幕,,0,0,0,,算法实际上出现在注释和TLA plus模块中 而是一个表达式\N{\r原文字幕}and the algorithm in fact appears in a comment and TLA plus module but an expression
Dialogue: 0,0:40:34.88,0:40:37.48,译文字幕,,0,0,0,,可以是任何TLA加表达式\N{\r原文字幕}can be any TLA plus expression
Dialogue: 0,0:40:37.72,0:40:40.66,译文字幕,,0,0,0,,它也有一些非决定论的构造\N{\r原文字幕}it also has some constructs for non determinism
Dialogue: 0,0:40:40.73,0:40:42.85,译文字幕,,0,0,0,,但事实上它可以是任何TLA\N{\r原文字幕}but the fact that it can be any TLA
Dialogue: 0,0:40:42.83,0:40:45.24,译文字幕,,0,0,0,,表达式可以是任何TLA plus表达式\N{\r原文字幕}an expression can be any TLA plus expression
Dialogue: 0,0:40:45.74,0:40:48.04,译文字幕,,0,0,0,,这意味着任何数学表达式\N{\r原文字幕}which means any expression of mathematics
Dialogue: 0,0:40:48.26,0:40:51.88,译文字幕,,0,0,0,,都使他更具表达性\N{\r原文字幕}makes it enormously powerful more more expressive than
Dialogue: 0,0:40:51.59,0:40:57.55,译文字幕,,0,0,0,,任何编程语言设计者梦寐以求的东西\N{\r原文字幕}anything any programming language designer has ever dreamed of
Dialogue: 0,0:40:57.37,0:41:02.02,译文字幕,,0,0,0,,它被编译成一个易于理解的TLA plus规范\N{\r原文字幕}and it gets compiled to an easy-to-understand TLA plus spec
Dialogue: 0,0:41:01.85,0:41:06.34,译文字幕,,0,0,0,,事实上 我经常用plus cal写东西\N{\r原文字幕}and in fact I regularly write things in plus cal
Dialogue: 0,0:41:06.14,0:41:08.83,译文字幕,,0,0,0,,当我证明它们的正确性时\N{\r原文字幕}and then when I'm proving the correctness of them
Dialogue: 0,0:41:08.51,0:41:11.58,译文字幕,,0,0,0,,我直接对TLA plus规范进行推理\N{\r原文字幕}I reason directly about the TLA plus specification
Dialogue: 0,0:41:12.08,0:41:15.13,译文字幕,,0,0,0,,你喜欢TLA plus工具模型检查器\N{\r原文字幕}and you like the TLA plus tools the model checker
Dialogue: 0,0:41:14.90,0:41:18.16,译文字幕,,0,0,0,,和定理证明器到加号到平移\N{\r原文字幕}and theorem prover to the plus to the translation
Dialogue: 0,0:41:20.55,0:41:25.95,译文字幕,,0,0,0,,永远运行的程序一直在谈论计算函数的程序\N{\r原文字幕}programs that run forever have been talking about programs that compute a function
Dialogue: 0,0:41:26.34,0:41:29.55,译文字幕,,0,0,0,,永远运行的程序通常涉及并发\N{\r原文字幕}programs that run forever usually involve concurrency
Dialogue: 0,0:41:30.09,0:41:33.45,译文字幕,,0,0,0,,像操作系统 分布式系统之类的东西\N{\r原文字幕}things like operating systems distributed systems
Dialogue: 0,0:41:33.78,0:41:36.27,译文字幕,,0,0,0,,很少有人能把它们做对\N{\r原文字幕}few people can get them right
Dialogue: 0,0:41:36.01,0:41:37.92,译文字幕,,0,0,0,,通过思考和写作\N{\r原文字幕}by just thinking and writing
Dialogue: 0,0:41:38.37,0:41:40.29,译文字幕,,0,0,0,,我不是他们中的一员\N{\r原文字幕}I'm not one of them
Dialogue: 0,0:41:40.53,0:41:44.76,译文字幕,,0,0,0,,我们需要工具来检查我们在做什么\N{\r原文字幕}we need tools to check what we're doing
Dialogue: 0,0:41:45.12,0:41:50.31,译文字幕,,0,0,0,,TLA plus对亚马逊工程师如此有用的原因是\N{\r原文字幕}the reason the TLA plus was so useful to the Amazon engineers is
Dialogue: 0,0:41:50.05,0:41:51.93,译文字幕,,0,0,0,,因为模型检查器\N{\r原文字幕}because the model checker
Dialogue: 0,0:41:52.62,0:41:58.44,译文字幕,,0,0,0,,因此 对于并发和分布式系统 您需要编写一些内容\N{\r原文字幕}so for concurrent and distributed systems you need to write something
Dialogue: 0,0:41:58.42,0:42:02.88,译文字幕,,0,0,0,,您可以使用TLA plus或plus Cal 它是为分布式系统设计的\N{\r原文字幕}you use TLA plus or plus Cal it was designed for distributed systems
Dialogue: 0,0:42:02.91,0:42:08.46,译文字幕,,0,0,0,,很好用 你不会轻易写出对的 分布式并发算法\N{\r原文字幕}it's great and you're not gonna get it you know distributed concurrent algorithm right
Dialogue: 0,0:42:08.20,0:42:09.63,译文字幕,,0,0,0,,如果不进行模型检查\N{\r原文字幕}if you don't model check
Dialogue: 0,0:42:09.52,0:42:13.71,译文字幕,,0,0,0,,如果它已经用完了 你不需要写一个规范并检查它\N{\r原文字幕}it it's spent you don't write a specification and check it
Dialogue: 0,0:42:14.16,0:42:19.89,译文字幕,,0,0,0,,其他95%非常简单的东西就是一个例子\N{\r原文字幕}the other 95% really simple stuff here is an example
Dialogue: 0,0:42:19.99,0:42:24.84,译文字幕,,0,0,0,,你知道我在程序中写的规范\N{\r原文字幕}of a spec you know that I write wrote in a program
Dialogue: 0,0:42:25.26,0:42:27.27,译文字幕,,0,0,0,,我为什么要写那个规范\N{\r原文字幕}why did I write that spec
Dialogue: 0,0:42:27.42,0:42:31.50,译文字幕,,0,0,0,,为了确保我在编写代码之前知道代码应该做什么\N{\r原文字幕}to be sure I knew what the code should do before writing it
Dialogue: 0,0:42:31.53,0:42:36.54,译文字幕,,0,0,0,,没有真正的写 我只认为它应该做什么是显而易见的\N{\r原文字幕}without writing aspect only thought it was obvious what it should do
Dialogue: 0,0:42:36.22,0:42:40.77,译文字幕,,0,0,0,,我必须编写规范 以确保它确实简单明了\N{\r原文字幕}I had to write the spec to be sure it was really as simple and as obvious
Dialogue: 0,0:42:40.72,0:42:42.06,译文字幕,,0,0,0,,正如我所想的那样\N{\r原文字幕}as I thought it was
Dialogue: 0,0:42:42.09,0:42:46.11,译文字幕,,0,0,0,,后来我不用读代码了\N{\r原文字幕}and later I didn't have to read the code
Dialogue: 0,0:42:45.91,0:42:49.20,译文字幕,,0,0,0,,想知道我写的那段代码做了什么\N{\r原文字幕}to know what that piece of code I wrote did
Dialogue: 0,0:42:49.18,0:42:52.74,译文字幕,,0,0,0,,我刚写了说明书可以看说明书\N{\r原文字幕}I just wrote the specification could read the specification
Dialogue: 0,0:42:52.99,0:42:59.52,译文字幕,,0,0,0,,所以一个一般规则 这是一个规则 至少我们可以说 一般规格\N{\r原文字幕}so a general rule that's one rule at least we can say about specs in general
Dialogue: 0,0:42:59.38,0:43:02.64,译文字幕,,0,0,0,,如果您正在编写代码应该做什么规范\N{\r原文字幕}if you're writing a spec of what a code should do
Dialogue: 0,0:43:02.32,0:43:04.65,译文字幕,,0,0,0,,一段代码应该做什么\N{\r原文字幕}what a piece of code should do
Dialogue: 0,0:43:04.30,0:43:09.30,译文字幕,,0,0,0,,这应该说明了任何人使用代码所需要知道的一切\N{\r原文字幕}that should say everything that anyone needs to know to use the code
Dialogue: 0,0:43:11.07,0:43:14.31,译文字幕,,0,0,0,,在我刚刚展示的示例中 代码是如何工作的\N{\r原文字幕}how the code worked in the example I've just showed
Dialogue: 0,0:43:14.35,0:43:16.41,译文字幕,,0,0,0,,只是太简单了 不需要一个规格\N{\r原文字幕}was just too simple to require a spec
Dialogue: 0,0:43:16.30,0:43:19.74,译文字幕,,0,0,0,,我是说这比我想象的要难\N{\r原文字幕}I mean it was it turned out to be harder than I thought
Dialogue: 0,0:43:19.27,0:43:22.17,译文字幕,,0,0,0,,当我开始编码时 我会发现\N{\r原文字幕}I would have discovered that when I started coding
Dialogue: 0,0:43:21.88,0:43:25.53,译文字幕,,0,0,0,,我会停止编码 写一个又一个规范\N{\r原文字幕}and I would have stopped coding and wrote and written a specification
Dialogue: 0,0:43:26.40,0:43:30.27,译文字幕,,0,0,0,,那么程序员应该知道什么是思考\N{\r原文字幕}so what programmers should know about thinking
Dialogue: 0,0:43:30.57,0:43:33.00,译文字幕,,0,0,0,,每个人都应该知道的思考\N{\r原文字幕}what everyone should know about thinking
Dialogue: 0,0:43:33.85,0:43:35.40,译文字幕,,0,0,0,,每个人都认为他们认为\N{\r原文字幕}everyone thinks they think
Dialogue: 0,0:43:36.09,0:43:39.12,译文字幕,,0,0,0,,但是如果你不写下你的想法\N{\r原文字幕}but if you don't write down your thoughts
Dialogue: 0,0:43:39.60,0:43:41.52,译文字幕,,0,0,0,,你在自欺欺人\N{\r原文字幕}you're fooling yourself
Dialogue: 0,0:43:42.45,0:43:45.00,译文字幕,,0,0,0,,关于思考 程序员应该知道什么\N{\r原文字幕}what programmers should know about thinking
Dialogue: 0,0:43:45.07,0:43:49.26,译文字幕,,0,0,0,,你在编写代码之前应该先思考\N{\r原文字幕}is that you should think before you code
Dialogue: 0,0:43:51.87,0:43:55.35,译文字幕,,0,0,0,,这意味着您应该在编写代码之前编写\N{\r原文字幕}which means you should write before you code
Dialogue: 0,0:43:55.12,0:43:59.55,译文字幕,,0,0,0,,说明书就是你在code前写的东西\N{\r原文字幕}a spec is simply what you write before coading
Dialogue: 0,0:43:59.97,0:44:04.29,译文字幕,,0,0,0,,所以什么教练 你知道我说的代码是什么意思 你应该具体说明什么\N{\r原文字幕}so what coach you know what do I mean by code what should you specify
Dialogue: 0,0:44:04.71,0:44:09.00,译文字幕,,0,0,0,,基本上 其他人可能想要使用或修改的任何一段代码\N{\r原文字幕}basically any piece of code that someone else might want to use or modifying
Dialogue: 0,0:44:08.98,0:44:13.71,译文字幕,,0,0,0,,一个月后别人很可能就是你\N{\r原文字幕}and that somebody else is likely to be you in a month
Dialogue: 0,0:44:13.45,0:44:16.14,译文字幕,,0,0,0,,当你忘记了你写的这段代码是做什么的时候\N{\r原文字幕}when you've forgotten what this piece of code you've written does
Dialogue: 0,0:44:16.89,0:44:21.78,译文字幕,,0,0,0,,它可以是整个程序或系统或类或方法\N{\r原文字幕}it could be an entire program or system a class a method
Dialogue: 0,0:44:22.18,0:44:25.08,译文字幕,,0,0,0,,只是方法内部的一段棘手的代码\N{\r原文字幕}just a tricky piece of code inside of a method
Dialogue: 0,0:44:26.19,0:44:28.98,译文字幕,,0,0,0,,关于代码 您应该指定什么\N{\r原文字幕}what should you specify about the code
Dialogue: 0,0:44:29.46,0:44:31.08,译文字幕,,0,0,0,,他应该是什么\N{\r原文字幕}what it does
Dialogue: 0,0:44:32.04,0:44:35.73,译文字幕,,0,0,0,,这意味着所有人使用它所需要知道的一切\N{\r原文字幕}which means everything anyone needs to know to use it
Dialogue: 0,0:44:35.56,0:44:38.58,译文字幕,,0,0,0,,还有它可能的做法\N{\r原文字幕}and perhaps how it does it
Dialogue: 0,0:44:38.26,0:44:43.71,译文字幕,,0,0,0,,如果它是复杂的 微妙的 你需要努力思考 以使他正常的工作\N{\r原文字幕}if it's complicated subtle you need to think hard about in order to get it right
Dialogue: 0,0:44:44.16,0:44:47.19,译文字幕,,0,0,0,,这有时被称为算法\N{\r原文字幕}this is you know what's sometimes called an algorithm
Dialogue: 0,0:44:47.11,0:44:48.54,译文字幕,,0,0,0,,或者高级设计\N{\r原文字幕}or a high-level design
Dialogue: 0,0:44:50.34,0:44:58.05,译文字幕,,0,0,0,,您应该如何考虑或指定高于代码级别的代码\N{\r原文字幕}how should you think about or specify your code above the code level
Dialogue: 0,0:44:57.97,0:45:02.09,译文字幕,,0,0,0,,在状态和行为方面\N{\r原文字幕}in terms of states and behaviors or
Dialogue: 0,0:45:03.09,0:45:05.51,译文字幕,,0,0,0,,输入输出关系函数\N{\r原文字幕}functions for input output relations
Dialogue: 0,0:45:05.52,0:45:07.23,译文字幕,,0,0,0,,应该用数学方法来做\N{\r原文字幕}should do it mathematically
Dialogue: 0,0:45:07.08,0:45:11.79,译文字幕,,0,0,0,,在必要的情况下 尽可能的严谨和非正式\N{\r原文字幕}as rigorously informally as is necessary
Dialogue: 0,0:45:12.57,0:45:14.85,译文字幕,,0,0,0,,你应该用数学思维\N{\r原文字幕}you should be thinking mathematically
Dialogue: 0,0:45:14.88,0:45:18.39,译文字幕,,0,0,0,,即使你写的是非常非正式的数学\N{\r原文字幕}even if you're writing thing the mathematics very informally
Dialogue: 0,0:45:20.01,0:45:23.67,译文字幕,,0,0,0,,可能使用伪代码或plus Cal\N{\r原文字幕}perhaps with pseudocode or pass or plus Cal
Dialogue: 0,0:45:23.44,0:45:26.19,译文字幕,,0,0,0,,如果你在说明某件事是如何发生的\N{\r原文字幕}if you're specifying how something does it
Dialogue: 0,0:45:26.49,0:45:28.83,译文字幕,,0,0,0,,那么 如何学习编写规范呢\N{\r原文字幕}so how do you learn to write specs
Dialogue: 0,0:45:29.64,0:45:35.76,译文字幕,,0,0,0,,通过编写正式的规范 即使你没有\N{\r原文字幕}by writing formal specs even if you don't
Dialogue: 0,0:45:35.53,0:45:39.57,译文字幕,,0,0,0,,即使您在生活中从来不需要编写完全正式的规范\N{\r原文字幕}even if you never need to write a completely formal spec in your life
Dialogue: 0,0:45:39.39,0:45:45.27,译文字幕,,0,0,0,,学习编写正式的规范将真正帮助你学习编写非正式的规范\N{\r原文字幕}learning to write formal specs will really help you learn to write the informal specs
Dialogue: 0,0:45:45.10,0:45:46.26,译文字幕,,0,0,0,,你需要写的\N{\r原文字幕}that you need to write
Dialogue: 0,0:45:46.69,0:45:51.64,译文字幕,,0,0,0,,你通过编写程序 运行程序和纠正错误来学习编写程序\N{\r原文字幕}you learn to write programs by writing them running them and correcting your errors
Dialogue: 0,0:45:51.85,0:45:57.52,译文字幕,,0,0,0,,您可以通过编写并运行规范来学习编写正式规范\N{\r原文字幕}you can learn to write formal specs by writing them running them
Dialogue: 0,0:45:57.35,0:45:59.98,译文字幕,,0,0,0,,用一个模型检查器来纠正你的错误\N{\r原文字幕}with a model checker and correcting your errors
Dialogue: 0,0:46:00.37,0:46:04.87,译文字幕,,0,0,0,,现在TL A+可能不是最适合你的语言\N{\r原文字幕}now TL A+ may not be the best language for you
Dialogue: 0,0:46:04.64,0:46:09.01,译文字幕,,0,0,0,,我肯定它不是最好的正式语言\N{\r原文字幕}you know it's I'm sure it's not the best language for formal language
Dialogue: 0,0:46:08.90,0:46:11.11,译文字幕,,0,0,0,,对于世界上每一种规格\N{\r原文字幕}for every kind of specification in the world
Dialogue: 0,0:46:10.82,0:46:12.34,译文字幕,,0,0,0,,任何语言都不能\N{\r原文字幕}no language can be
Dialogue: 0,0:46:12.16,0:46:17.59,译文字幕,,0,0,0,,对于你的特殊需求 它可能不是你所知道的最好的语言形式\N{\r原文字幕}it may not be the best form of language you know for what your particular needs are
Dialogue: 0,0:46:17.27,0:46:20.20,译文字幕,,0,0,0,,但我知道这对\N{\r原文字幕}but I do know that it's great for
Dialogue: 0,0:46:20.21,0:46:21.40,译文字幕,,0,0,0,,学会数学思考是很棒的\N{\r原文字幕}learning to think mathematically
Dialogue: 0,0:46:21.91,0:46:29.89,译文字幕,,0,0,0,,所以除非你能找到更好的方法来做这件事 否则你应该使用TLA plus\N{\r原文字幕}so unless you can find something better for doing that you know which works use TL a plus
Dialogue: 0,0:46:29.72,0:46:31.33,译文字幕,,0,0,0,,你知道学习TLA+\N{\r原文字幕}you know learn TL a plus
Dialogue: 0,0:46:31.10,0:46:32.35,译文字幕,,0,0,0,,学会数学思考\N{\r原文字幕}learn to think mathematically
Dialogue: 0,0:46:34.33,0:46:37.12,译文字幕,,0,0,0,,如何将规范与代码连接起来\N{\r原文字幕}how do you connect the spec to the code
Dialogue: 0,0:46:37.57,0:46:42.37,译文字幕,,0,0,0,,好吧 你有连接数学概念和它们的实现的注释\N{\r原文字幕}well you have comments connecting mathematical concepts and their implementation
Dialogue: 0,0:46:42.11,0:46:45.37,译文字幕,,0,0,0,,例如 数学概念可能\N{\r原文字幕}for example the mathematical concept might
Dialogue: 0,0:46:45.08,0:46:45.79,译文字幕,,0,0,0,,是一个图形\N{\r原文字幕}be a graph
Dialogue: 0,0:46:45.65,0:46:51.70,译文字幕,,0,0,0,,实现可能是一个节点对象数组和一个链接对象数组\N{\r原文字幕}and the implementation would be an array of node objects and an array of link objects
Dialogue: 0,0:46:51.85,0:46:56.47,译文字幕,,0,0,0,,在这方面 特别是另一种说明书\N{\r原文字幕}in this connection the other specification especially
Dialogue: 0,0:46:56.75,0:46:59.11,译文字幕,,0,0,0,,如果是非正式的规范 应该在注释中\N{\r原文字幕}if it's an informal specification should be in the comments
Dialogue: 0,0:46:59.09,0:47:03.01,译文字幕,,0,0,0,,也应该解释这些数学\N{\r原文字幕}and so should the explanation of how those mathematical
Dialogue: 0,0:47:02.84,0:47:05.32,译文字幕,,0,0,0,,注释在代码中实现\N{\r原文字幕}comments are implemented in the code
Dialogue: 0,0:47:05.06,0:47:07.51,译文字幕,,0,0,0,,那么编码呢\N{\r原文字幕}so what about coding
Dialogue: 0,0:47:07.52,0:47:10.99,译文字幕,,0,0,0,,我的意思是 我们的程序涉及到编写代码 你必须编写代码\N{\r原文字幕}I mean we're programs involve writing code you have to write code
Dialogue: 0,0:47:10.91,0:47:14.08,译文字幕,,0,0,0,,关于写代码我没什么好说的\N{\r原文字幕}I have nothing to say about writing code
Dialogue: 0,0:47:13.90,0:47:16.21,译文字幕,,0,0,0,,我说的没有任何暗示\N{\r原文字幕}nothing I said implies anything
Dialogue: 0,0:47:16.72,0:47:19.87,译文字幕,,0,0,0,,在编写代码时 您仍然需要思考\N{\r原文字幕}you still have to think while you code
Dialogue: 0,0:47:19.78,0:47:22.60,译文字幕,,0,0,0,,这意味着你必须一边写一边编码\N{\r原文字幕}which means you have to write while you're coding
Dialogue: 0,0:47:22.52,0:47:25.90,译文字幕,,0,0,0,,但是你在编码的时候是正确的\N{\r原文字幕}but what you're right while you're coding is is code
Dialogue: 0,0:47:26.71,0:47:30.01,译文字幕,,0,0,0,,我对你应该如何编码没什么可说的\N{\r原文字幕}and I have nothing to say about how you should code
Dialogue: 0,0:47:29.72,0:47:31.66,译文字幕,,0,0,0,,使用任何你想要的编程语言\N{\r原文字幕}use any programming language you want
Dialogue: 0,0:47:31.67,0:47:33.28,译文字幕,,0,0,0,,任何编程方法\N{\r原文字幕}any programming methodology
Dialogue: 0,0:47:33.97,0:47:38.26,译文字幕,,0,0,0,,你仍然你仍然要测试和调试你的程序\N{\r原文字幕}you still you're still going to have to test and debug your program
Dialogue: 0,0:47:38.56,0:47:43.36,译文字幕,,0,0,0,,这不是一个好的写作方面 我们要捕捉编码错误\N{\r原文字幕}not this good writing aspect is we're going to catch coding errors
Dialogue: 0,0:47:43.16,0:47:44.56,译文字幕,,0,0,0,,因为这与编码无关\N{\r原文字幕}because it's not about coding
Dialogue: 0,0:47:44.54,0:47:46.93,译文字幕,,0,0,0,,它会捕捉算法错误\N{\r原文字幕}it'll catch algorithm errors
Dialogue: 0,0:47:48.04,0:47:50.83,译文字幕,,0,0,0,,编写规范是另外一个步骤\N{\r原文字幕}writing specs is an additional step
Dialogue: 0,0:47:50.60,0:47:54.52,译文字幕,,0,0,0,,并且可以通过及早发现错误来节省时间\N{\r原文字幕}and it may save time by catching errors early
Dialogue: 0,0:47:54.26,0:47:57.79,译文字幕,,0,0,0,,当他们更容易纠正，但不绝对\N{\r原文字幕}when they're easier to correct no promises there
Dialogue: 0,0:47:57.53,0:48:00.73,译文字幕,,0,0,0,,它肯定会提高你的编程能力\N{\r原文字幕}it certainly will improve you programming
Dialogue: 0,0:48:00.86,0:48:02.92,译文字幕,,0,0,0,,所以你会写出更好的程序\N{\r原文字幕}so you'll be writing better programs
Dialogue: 0,0:48:03.91,0:48:06.88,译文字幕,,0,0,0,,为什么程序员不愿意写规范\N{\r原文字幕}why are programmers reluctant to write specs
Dialogue: 0,0:48:06.95,0:48:09.70,译文字幕,,0,0,0,,尽管写作很难\N{\r原文字幕}well writing is hard writing is hard
Dialogue: 0,0:48:09.41,0:48:11.05,译文字幕,,0,0,0,,思考更难\N{\r原文字幕}in fact because thinking is hard
Dialogue: 0,0:48:10.99,0:48:13.63,译文字幕,,0,0,0,,你知道没有通往数学的捷径\N{\r原文字幕}you know there's no Royal Road to mathematics
Dialogue: 0,0:48:13.97,0:48:18.19,译文字幕,,0,0,0,,好像是阿基米德说的\N{\r原文字幕}as who wasn't who said that Archimedes I think
Dialogue: 0,0:48:19.39,0:48:23.41,译文字幕,,0,0,0,,为什么写作很难 因为写作需要思考\N{\r原文字幕}why is writing hard well because writing requires thinking
Dialogue: 0,0:48:23.21,0:48:24.97,译文字幕,,0,0,0,,而思考很难\N{\r原文字幕}and thinking is hard
Dialogue: 0,0:48:24.71,0:48:27.97,译文字幕,,0,0,0,,就像我说的 你更容易认为你在思考\N{\r原文字幕}and as I said it's easier to think you're thinking
Dialogue: 0,0:48:28.18,0:48:30.31,译文字幕,,0,0,0,,写作很像跑步\N{\r原文字幕}writing is a lot like running
Dialogue: 0,0:48:30.52,0:48:33.64,译文字幕,,0,0,0,,除非你做得慢一点\N{\r原文字幕}unless you do it slower you are
Dialogue: 0,0:48:33.17,0:48:36.43,译文字幕,,0,0,0,,你必须加强你的写作能力\N{\r原文字幕}and you have to strengthen your writing muscles
Dialogue: 0,0:48:36.35,0:48:38.32,译文字幕,,0,0,0,,你知道就像你必须加强你的意志\N{\r原文字幕}you know just like you have to strengthen your rust
Dialogue: 0,0:48:38.06,0:48:40.48,译文字幕,,0,0,0,,和你的肌肉，这需要练习\N{\r原文字幕}and you're running muscles it takes practice
Dialogue: 0,0:48:40.22,0:48:43.96,译文字幕,,0,0,0,,找个借口不这么做更容易\N{\r原文字幕}and it's easier to find an excuse not to
Dialogue: 0,0:48:44.41,0:48:48.52,译文字幕,,0,0,0,,还有一个最好的借口 如果规格是错误的呢\N{\r原文字幕}and one of the nicest excuses well what if the spec is wrong
Dialogue: 0,0:48:48.37,0:48:50.79,译文字幕,,0,0,0,,也许你在说明书上弄错了\N{\r原文字幕}maybe you made a mistake in the spec
Dialogue: 0,0:48:50.80,0:48:53.50,译文字幕,,0,0,0,,也许需求在哪里改变了\N{\r原文字幕}maybe the requirements change where
Dialogue: 0,0:48:53.27,0:48:54.67,译文字幕,,0,0,0,,需要进行一些改进\N{\r原文字幕}some enhancement is needed
Dialogue: 0,0:48:54.53,0:49:01.78,译文字幕,,0,0,0,,事实上 代码将不得不改变 甚至在程序完成之前\N{\r原文字幕}in fact and the code will have to be changed maybe even before the program is finished
Dialogue: 0,0:49:01.84,0:49:07.75,译文字幕,,0,0,0,,事实上 更改代码\N{\r原文字幕}in fact changing the code is something that
Dialogue: 0,0:49:07.52,0:49:09.79,译文字幕,,0,0,0,,最终会发生在所有有用的程序上\N{\r原文字幕}eventually happens to all useful programs
Dialogue: 0,0:49:10.46,0:49:11.80,译文字幕,,0,0,0,,你的程序很有用\N{\r原文字幕}your program is useful
Dialogue: 0,0:49:12.28,0:49:18.28,译文字幕,,0,0,0,,它会有用户 用户会找到他们想要的东西\N{\r原文字幕}it's gonna have users the users are going to find things extra things they want of it
Dialogue: 0,0:49:17.93,0:49:20.44,译文字幕,,0,0,0,,那些不能正常工作的事情\N{\r原文字幕}the things that don't work the way
Dialogue: 0,0:49:19.97,0:49:23.13,译文字幕,,0,0,0,,从客户视角考虑是个好想法\N{\r原文字幕}you know you thought was a good idea be your customers
Dialogue: 0,0:49:23.63,0:49:27.79,译文字幕,,0,0,0,,否则这种情况最终会发生在所有有用的程序\N{\r原文字幕}you know decide otherwise this happens eventually happens to all useful programs
Dialogue: 0,0:49:28.15,0:49:32.41,译文字幕,,0,0,0,,在一个理想的世界里 你会写一个新的规范\N{\r原文字幕}in an ideal world you'd write a new spec
Dialogue: 0,0:49:32.30,0:49:36.31,译文字幕,,0,0,0,,然后你知道代码 你会完全重写规范的规范\N{\r原文字幕}and then you know the code you'd completely rewrite the spec of the spec
Dialogue: 0,0:49:36.11,0:49:38.92,译文字幕,,0,0,0,,我们都知道这是不可能的\N{\r原文字幕}well we all know this isn't gonna happen
Dialogue: 0,0:49:38.87,0:49:42.25,译文字幕,,0,0,0,,在现实世界中 代码是打补丁的\N{\r原文字幕}in the real world the code is patched
Dialogue: 0,0:49:42.05,0:49:44.77,译文字幕,,0,0,0,,如果你幸运的话 规范更新了\N{\r原文字幕}and if you're lucky the spec is updated
Dialogue: 0,0:49:45.40,0:49:50.26,译文字幕,,0,0,0,,好吧 如果这是不可避免的 为什么要费心写规格在第一位\N{\r原文字幕}well if this is inevitable why bother writing specs in the first place
Dialogue: 0,0:49:50.03,0:49:52.96,译文字幕,,0,0,0,,如果这个小可爱（规范）\N{\r原文字幕}if you know this little lovely thing is
Dialogue: 0,0:49:52.97,0:49:57.30,译文字幕,,0,0,0,,不得不改变\N{\r原文字幕}you know the spec turns out you know - has to be changed and you know
Dialogue: 0,0:49:57.80,0:50:00.22,译文字幕,,0,0,0,,我们又回到了过去那个乱七八糟的世界\N{\r原文字幕}we're back in our old messy world
Dialogue: 0,0:49:59.96,0:50:01.75,译文字幕,,0,0,0,,有两个原因\N{\r原文字幕}well there's two reasons
Dialogue: 0,0:50:01.28,0:50:06.61,译文字幕,,0,0,0,,第一个原因是无论是不得不修改代码的谁\N{\r原文字幕}the first reason is that whoever has to modify the code
Dialogue: 0,0:50:06.73,0:50:12.73,译文字幕,,0,0,0,,都将永远感激你所写的每一个字或每一个公式\N{\r原文字幕}will be eternally grateful for every word or formula of specification that you write
Dialogue: 0,0:50:12.84,0:50:18.59,译文字幕,,0,0,0,,不管是谁 也许你 相信我 你这样做了 然后你回头看\N{\r原文字幕}and whoever maybe you believe me I've you've done that you know coming back
Dialogue: 0,0:50:18.65,0:50:21.35,译文字幕,,0,0,0,,没有时间听第二个故事\N{\r原文字幕}and don't have time for second stories
Dialogue: 0,0:50:21.36,0:50:24.98,译文字幕,,0,0,0,,特别是修改和漂亮的印刷 事实上\N{\r原文字幕}but particularly you know modifications and the pretty print or in fact
Dialogue: 0,0:50:25.43,0:50:30.95,译文字幕,,0,0,0,,这就是为什么在更改代码时应该更新规范的原因\N{\r原文字幕}and that's why you should update the spec when you change the code
Dialogue: 0,0:50:31.22,0:50:36.92,译文字幕,,0,0,0,,第二个原因是每次代码被修补\N{\r原文字幕}the second reason is that every time code is patched
Dialogue: 0,0:50:36.75,0:50:41.75,译文字幕,,0,0,0,,它变得更难看 更难理解 更难维护\N{\r原文字幕}it becomes a little uglier harder to understand and harder to maintain
Dialogue: 0,0:50:43.82,0:50:51.05,译文字幕,,0,0,0,,但是如果你不从一个规范开始你写的每一段代码\N{\r原文字幕}and if you but if you don't start with a spec every piece of code you write
Dialogue: 0,0:50:50.79,0:50:56.18,译文字幕,,0,0,0,,都将成为补丁 这意味着程序从头开始\N{\r原文字幕}is a patch which means the program starts out from the beginning
Dialogue: 0,0:50:56.15,0:50:59.12,译文字幕,,0,0,0,,难看 难以理解 难以理解\N{\r原文字幕}being ugly hard to understand and hard
Dialogue: 0,0:50:59.13,0:51:02.81,译文字幕,,0,0,0,,当你需要维持的时候 只能祈求上帝\N{\r原文字幕}to maintain and then God help you when you do have to maintain
Dialogue: 0,0:51:02.67,0:51:07.15,译文字幕,,0,0,0,,帮你知道这段代码是啥意思\N{\r原文字幕}you know try to unfit out what it's doing in order to to
Dialogue: 0,0:51:07.65,0:51:12.95,译文字幕,,0,0,0,,正如德怀特·艾森豪威尔所说\N{\r原文字幕}make changes as Dwight Eisenhower said
Dialogue: 0,0:51:13.10,0:51:16.40,译文字幕,,0,0,0,,计划决定不了战争的胜负\N{\r原文字幕}no battle was ever won according to plan
Dialogue: 0,0:51:16.76,0:51:19.67,译文字幕,,0,0,0,,但战争的胜利离不开计划\N{\r原文字幕}but no battle was ever won with that one
Dialogue: 0,0:51:20.84,0:51:22.91,译文字幕,,0,0,0,,所以有些人会告诉你\N{\r原文字幕}so some people will tell you that
Dialogue: 0,0:51:22.92,0:51:24.71,译文字幕,,0,0,0,,写规格是浪费时间\N{\r原文字幕}writing specs is a waste of time
Dialogue: 0,0:51:24.92,0:51:27.53,译文字幕,,0,0,0,,在某些情况下可能确实这样\N{\r原文字幕}in some situations and maybe
Dialogue: 0,0:51:28.34,0:51:33.17,译文字幕,,0,0,0,,有时候你不需要去想你在做什么 也许有些事情真的很琐碎\N{\r原文字幕}sometimes there's no need to think about what you're doing maybe something is really so trivial
Dialogue: 0,0:51:33.18,0:51:35.30,译文字幕,,0,0,0,,不需要太多思考\N{\r原文字幕}that you know doesn't need much thought
Dialogue: 0,0:51:35.63,0:51:40.46,译文字幕,,0,0,0,,但是当他们告诉你不要写规范的时候 我们得知道\N{\r原文字幕}but we'll remember when they're telling you not to write a spec
Dialogue: 0,0:51:40.38,0:51:43.76,译文字幕,,0,0,0,,他们其实是告诉你不要思考\N{\r原文字幕}they're telling really telling you not to think
Dialogue: 0,0:51:43.67,0:51:48.68,译文字幕,,0,0,0,,可你知道思考是一个很好的主意\N{\r原文字幕}and you know thinking is a really good idea
Dialogue: 0,0:51:48.21,0:51:51.83,译文字幕,,0,0,0,,不要相信任何告诉你不要这样做的人\N{\r原文字幕}and don't trust anybody who tells you not to do it
Dialogue: 0,0:51:52.19,0:51:55.34,译文字幕,,0,0,0,,思考并不能保证你不会犯错误\N{\r原文字幕}thinking doesn't guarantee that you won't make mistakes
Dialogue: 0,0:51:55.91,0:51:59.78,译文字幕,,0,0,0,,但是不思考通常保证你会\N{\r原文字幕}but not thinking generally guarantees that you will
Dialogue: 0,0:52:00.53,0:52:07.22,译文字幕,,0,0,0,,了解有关TLA plus的更多信息请访问我的主页并单击TLA网页的链接\N{\r原文字幕}find out more about TLA plus go to my home page and click on the link to the TLA web page
Dialogue: 0,0:52:07.19,0:52:08.69,译文字幕,,0,0,0,,感谢\N{\r原文字幕}thank you
Dialogue: 0,0:52:09.22,0:52:09.72,原文字幕,,0,0,0,,[Applause]
Dialogue: 0,0:52:15.86,0:52:18.64,译文字幕,,0,0,0,,Q&A环节\N{\r原文字幕}I think there's time for a few questions
Dialogue: 0,0:52:21.25,0:52:23.17,译文字幕,,0,0,0,,时间比较紧\N{\r原文字幕}very few I think
Dialogue: 0,0:52:23.62,0:52:25.69,原文字幕,,0,0,0,,one yeah yes
Dialogue: 0,0:52:25.97,0:52:33.13,译文字幕,,0,0,0,,我希望这不是对我讲话的评判\N{\r原文字幕}I hope that's not a judgment on my talk
Dialogue: 0,0:52:35.17,0:52:36.91,原文字幕,,0,0,0,,thanks for your talk
Dialogue: 0,0:52:36.86,0:52:39.25,译文字幕,,0,0,0,,怎么看规范在\N{\r原文字幕}how about specification by example
Dialogue: 0,0:52:39.68,0:52:44.95,译文字幕,,0,0,0,,测试驱动开发启发的实用方法下的应用呢\N{\r原文字幕}it's a pragmatic approach that is a little bit inspired by test-driven development
Dialogue: 0,0:52:45.04,0:52:50.82,译文字幕,,0,0,0,,当然 因为它还不完整\N{\r原文字幕}which since it's not complete of course
Dialogue: 0,0:52:50.83,0:52:54.16,译文字幕,,0,0,0,,但是因为完备性无论如何都是不可判定的\N{\r原文字幕}but since completeness anyway is undecidable
Dialogue: 0,0:52:54.38,0:52:58.51,译文字幕,,0,0,0,,这是一个很好的实用方法 所以你知道吗\N{\r原文字幕}it's a good pragmatic approach so do you know
Dialogue: 0,0:52:58.16,0:53:02.11,译文字幕,,0,0,0,,如此糟糕的务实方法也许是个好方法\N{\r原文字幕}so terrible pragmatic approach it's maybe a good
Dialogue: 0,0:53:01.70,0:53:06.73,译文字幕,,0,0,0,,也许这是一个很好的方法来解释什么东西 例子很好地解释了它们\N{\r原文字幕}maybe a good way to explain what something examples are great to explain them
Dialogue: 0,0:53:06.44,0:53:09.37,译文字幕,,0,0,0,,但它们很可怕它们让你无法思考\N{\r原文字幕}but they're terrible they keep you from thinking
Dialogue: 0,0:53:09.41,0:53:11.95,译文字幕,,0,0,0,,从这些特殊的例子来看\N{\r原文字幕}you think in terms of these particular examples
Dialogue: 0,0:53:12.05,0:53:17.59,译文字幕,,0,0,0,,编程中真正的问题是不要去想那些简单的例子和显而易见的例子\N{\r原文字幕}the real problem in programming is not to think of your the easy cases the obvious cases
Dialogue: 0,0:53:17.33,0:53:19.72,译文字幕,,0,0,0,,好例子，hard例子\N{\r原文字幕}the nice case if the hard cases
Dialogue: 0,0:53:19.55,0:53:21.82,译文字幕,,0,0,0,,你不能用例子来理解\N{\r原文字幕}and you don't get that with examples
Dialogue: 0,0:53:21.86,0:53:24.52,译文字幕,,0,0,0,,我会告诉你我曾经eclipse编程\N{\r原文字幕}and boy I'll tell you I used to eclipse programming
Dialogue: 0,0:53:24.79,0:53:33.25,译文字幕,,0,0,0,,我知道有这么多这么多的eclipse方法\N{\r原文字幕}and I've you know there's so much so many methods of eclipse
Dialogue: 0,0:53:33.65,0:53:38.50,译文字幕,,0,0,0,,下面是一个使用它的代码示例\N{\r原文字幕}that are explained by here's an here's an example of code using it
Dialogue: 0,0:53:38.27,0:53:44.80,译文字幕,,0,0,0,,我还没有设法用这些方法来做我想做的事\N{\r原文字幕}and I have yet to manage to use those methods to do it what I want to do
Dialogue: 0,0:53:44.48,0:53:48.94,译文字幕,,0,0,0,,因为它不起作用 我发现除了这个例子之外 它对其他任何东西都不起作用\N{\r原文字幕}because it doesn't work I find that it just doesn't work on anything other than that example
Dialogue: 0,0:53:48.80,0:53:50.41,译文字幕,,0,0,0,,并且我束手无策\N{\r原文字幕}and I have no idea why not
Dialogue: 0,0:53:50.20,0:53:53.80,译文字幕,,0,0,0,,不是一个你知道的通过例子编程的程序\N{\r原文字幕}not a program you know programming by example
Dialogue: 0,0:53:53.84,0:53:56.20,译文字幕,,0,0,0,,我不知道这是否有效\N{\r原文字幕}I don't know about you know if that works
Dialogue: 0,0:53:56.00,0:53:59.02,译文字幕,,0,0,0,,但举例说明却没有\N{\r原文字幕}but a specification by example it doesn't
Dialogue: 0,0:54:09.63,0:54:11.85,译文字幕,,0,0,0,,谢谢你的精彩演讲\N{\r原文字幕}thank you for the great talk um
Dialogue: 0,0:54:11.83,0:54:14.07,译文字幕,,0,0,0,,那么一旦你修补了代码 会发生什么呢\N{\r原文字幕}so what happens once you patch the code
Dialogue: 0,0:54:13.75,0:54:16.71,译文字幕,,0,0,0,,你建议保留旧的规格还是\N{\r原文字幕}do you suggest keeping the old specs around or
Dialogue: 0,0:54:16.60,0:54:17.88,译文字幕,,0,0,0,,还是直接删了\N{\r原文字幕}do you just get rid of him
Dialogue: 0,0:54:17.56,0:54:19.59,译文字幕,,0,0,0,,比如有上下文有帮助吗\N{\r原文字幕}like does it help to have context
Dialogue: 0,0:54:24.06,0:54:31.83,译文字幕,,0,0,0,,首先 我认为每当我修复错误 这可能需要改变规范\N{\r原文字幕}well first of all I think whenever I well whenever I do fix bugs and that may require changing the spec
Dialogue: 0,0:54:31.63,0:54:35.58,译文字幕,,0,0,0,,我还会记下我为什么要更改规范\N{\r原文字幕}I will also take a note as to why I change the spec
Dialogue: 0,0:54:35.40,0:54:39.81,译文字幕,,0,0,0,,因为你知道两年后我会回来\N{\r原文字幕}because you know two years later I'm going to come back
Dialogue: 0,0:54:39.34,0:54:40.95,译文字幕,,0,0,0,,然后说我为什么要这么做\N{\r原文字幕}and say why did I do that
Dialogue: 0,0:54:41.67,0:54:45.00,译文字幕,,0,0,0,,是否这在多大程度上是有用的\N{\r原文字幕}about whether you know to what extent that's useful
Dialogue: 0,0:54:45.36,0:54:50.31,译文字幕,,0,0,0,,对于规范本身我不知道\N{\r原文字幕}for the specification itself I don't know
Dialogue: 0,0:54:50.17,0:54:53.58,译文字幕,,0,0,0,,当然 不扔掉任何东西总是个好主意\N{\r原文字幕}certainly you're always a good idea not to throw anything away
Dialogue: 0,0:54:53.32,0:54:57.90,译文字幕,,0,0,0,,不应该扔掉\N{\r原文字幕}you know we shouldn't be throwing you know information away these days you know
Dialogue: 0,0:54:57.52,0:55:02.13,译文字幕,,0,0,0,,又不占地方，留着呗\N{\r原文字幕}it doesn't cost anything to save it so you should certainly save the old specs
Dialogue: 0,0:55:02.11,0:55:04.89,译文字幕,,0,0,0,,你是否应该知道\N{\r原文字幕}whether you should you know
Dialogue: 0,0:55:04.51,0:55:07.50,译文字幕,,0,0,0,,至于你是否应该在新规范中记录更改\N{\r原文字幕}whether you should mention the change in the
Dialogue: 0,0:55:07.57,0:55:10.62,译文字幕,,0,0,0,,我也没\N{\r原文字幕}in the new spec I don't I don't have any
Dialogue: 0,0:55:10.27,0:55:12.87,译文字幕,,0,0,0,,啥确定的答案\N{\r原文字幕}any good answer to that
Dialogue: 0,0:55:17.43,0:55:23.79,译文字幕,,0,0,0,,我不想无礼 我认为大多数程序员\N{\r原文字幕}without wanting to be rude or anything I think most programmers
Dialogue: 0,0:55:24.12,0:55:27.03,译文字幕,,0,0,0,,不再使用正式的规范\N{\r原文字幕}don't use formal specifications anymore
Dialogue: 0,0:55:26.89,0:55:28.29,译文字幕,,0,0,0,,我的博士就是在这个背景下\N{\r原文字幕}my PhD was in that background
Dialogue: 0,0:55:28.18,0:55:33.03,译文字幕,,0,0,0,,现在大多数程序员 他们采用算法 他们采用代码\N{\r原文字幕}most programmers these days they take algorithms they take code
Dialogue: 0,0:55:32.86,0:55:34.38,译文字幕,,0,0,0,,他们根据自己想做的事情来调整\N{\r原文字幕}they adapt it to what they want to do
Dialogue: 0,0:55:34.39,0:55:37.50,译文字幕,,0,0,0,,从我的角度来看 这是99%的\N{\r原文字幕}and that's 99 percent is from my perspective
Dialogue: 0,0:55:37.33,0:55:39.75,译文字幕,,0,0,0,,软件是这样构建的\N{\r原文字幕}how most software is built these days
Dialogue: 0,0:55:40.89,0:55:44.79,译文字幕,,0,0,0,,那很好啊 如果它\N{\r原文字幕}that we actually really be nice if it
Dialogue: 0,0:55:44.41,0:55:48.78,译文字幕,,0,0,0,,如果那样就完事了那很好啊\N{\r原文字幕}if that where it can build Bell built well that way
Dialogue: 0,0:55:49.81,0:55:53.67,译文字幕,,0,0,0,,它不起作用 因为他们试图使用\N{\r原文字幕}it doesn't work because they're trying to use
Dialogue: 0,0:55:53.41,0:55:58.26,译文字幕,,0,0,0,,我发现它不起作用是因为其他代码\N{\r原文字幕}I find that it doesn't work because the other pieces of code
Dialogue: 0,0:55:58.06,0:56:00.75,译文字幕,,0,0,0,,那些没有规范的其他代码\N{\r原文字幕}that I want to use don't have specifications
Dialogue: 0,0:56:01.15,0:56:03.54,译文字幕,,0,0,0,,所以我真的不能很好地使用它们\N{\r原文字幕}so I really can't use them very well
Dialogue: 0,0:56:03.43,0:56:05.22,译文字幕,,0,0,0,,我尽力了\N{\r原文字幕}I do the best I can
Dialogue: 0,0:56:04.78,0:56:10.23,译文字幕,,0,0,0,,我老卷了，花了老鼻子时间在\N{\r原文字幕}and I wind up having to spend a hell of a lot of time
Dialogue: 0,0:56:10.68,0:56:14.10,译文字幕,,0,0,0,,试图明白那段代码干啥的\N{\r原文字幕}trying to figure out what this piece of code does
Dialogue: 0,0:56:14.91,0:56:18.18,译文字幕,,0,0,0,,但如果有规范，我就不必这么累\N{\r原文字幕}which something I shouldn't have to do if it had been specified
Dialogue: 0,0:56:19.25,0:56:22.72,译文字幕,,0,0,0,,我再说一遍 你知道95%的编程\N{\r原文字幕}again I've said that you know 95% of programming
Dialogue: 0,0:56:23.92,0:56:27.37,译文字幕,,0,0,0,,只需要很少的规格\N{\r原文字幕}you know requires very little specification
Dialogue: 0,0:56:27.80,0:56:33.85,译文字幕,,0,0,0,,几行通常就足够了\N{\r原文字幕}and you know a few lines you know are usually enough
Dialogue: 0,0:56:33.70,0:56:36.88,译文字幕,,0,0,0,,但还有5%\N{\r原文字幕}but you know you are going to come up with this 5%
Dialogue: 0,0:56:36.89,0:56:40.03,译文字幕,,0,0,0,,这不仅仅是把东西放在一块\N{\r原文字幕}which isn't just you know take this thing and put it here
Dialogue: 0,0:56:39.56,0:56:41.11,译文字幕,,0,0,0,,连上他们\N{\r原文字幕}and combine it with this thing
Dialogue: 0,0:56:40.69,0:56:44.62,译文字幕,,0,0,0,,你得写一些代码\N{\r原文字幕}there's gonna be something some things code you're gonna have to write
Dialogue: 0,0:56:44.33,0:56:50.29,译文字幕,,0,0,0,,这是微妙的 它有点困难\N{\r原文字幕}that is subtle it has some some a bit of difficulty in it
Dialogue: 0,0:56:49.91,0:56:53.59,译文字幕,,0,0,0,,你想为此做好准备\N{\r原文字幕}and you want to be able to you know you want to be prepared for that
Dialogue: 0,0:56:53.45,0:56:55.81,译文字幕,,0,0,0,,因为我们使用同样的技术\N{\r原文字幕}because we use the same techniques that
Dialogue: 0,0:56:55.82,0:56:58.03,译文字幕,,0,0,0,,和同样的思想漏洞\N{\r原文字幕}you use you're the same lack of thought
Dialogue: 0,0:56:58.04,0:57:00.10,译文字幕,,0,0,0,,当你做其他95%的事情时\N{\r原文字幕}that you use when you're doing that other 95%
Dialogue: 0,0:57:00.58,0:57:02.68,译文字幕,,0,0,0,,你会搞砸的\N{\r原文字幕}you're gonna screw up badly
Dialogue: 0,0:57:12.40,0:57:15.97,译文字幕,,0,0,0,,不幸的是 我从来没有真正研究过TLA plus\N{\r原文字幕}unfortunately I have never really looked into TLA plus
Dialogue: 0,0:57:16.28,0:57:24.79,译文字幕,,0,0,0,,但是研究了时态逻辑之后 不可避免地会注意不到这一点\N{\r原文字幕}but having studied temporal logic it is inevitable to to fail to to notice that
Dialogue: 0,0:57:24.74,0:57:26.71,译文字幕,,0,0,0,,有很多时间逻辑\N{\r原文字幕}that there's a lot of temporal logic
Dialogue: 0,0:57:26.68,0:57:29.53,译文字幕,,0,0,0,,在你所说的底层\N{\r原文字幕}going on underlying what you've been saying
Dialogue: 0,0:57:29.33,0:57:38.02,译文字幕,,0,0,0,,所以我想知道你有没有研究过也许你有可能\N{\r原文字幕}so I was wondering have you studied probably you have the possibilities
Dialogue: 0,0:57:38.21,0:57:41.35,译文字幕,,0,0,0,,更直接地使用时态逻辑的语言\N{\r原文字幕}for using more directly the language of temporal logic
Dialogue: 0,0:57:41.27,0:57:46.27,译文字幕,,0,0,0,,未来将作为必要性运营商和所有的东西 所以\N{\r原文字幕}will future operates as necessity operators and all that stuff and so
Dialogue: 0,0:57:46.46,0:57:50.92,译文字幕,,0,0,0,,ok TLA代表动作的时序逻辑\N{\r原文字幕}ok TLA stands for the temporal logic of actions
Dialogue: 0,0:57:52.18,0:57:54.34,译文字幕,,0,0,0,,时序逻辑是邪恶的\N{\r原文字幕}temporal logic is evil
Dialogue: 0,0:57:54.50,0:57:59.47,译文字幕,,0,0,0,,我可以告诉你解释为什么 因为它很难使用\N{\r原文字幕}I can tell you explain why because it's very hard to use
Dialogue: 0,0:57:59.12,0:58:01.72,译文字幕,,0,0,0,,但事实证明这是一种必要的罪恶\N{\r原文字幕}but it turns out it's a necessary evil
Dialogue: 0,0:58:02.89,0:58:07.54,译文字幕,,0,0,0,,时序逻辑被证明是思考活力的最佳方式\N{\r原文字幕}temporal logic turns out to be the best way of thinking about liveness
Dialogue: 0,0:58:07.67,0:58:13.72,译文字幕,,0,0,0,,所以如果你使用TLA plus当你到达活性部分时\N{\r原文字幕}and so if you use TLA plus when you get to the liveness part you're
Dialogue: 0,0:58:13.46,0:58:16.03,译文字幕,,0,0,0,,将使用时序逻辑 并注意到这一点\N{\r原文字幕}going to be using temporal logic and be aware of it
Dialogue: 0,0:58:15.74,0:58:22.51,译文字幕,,0,0,0,,但请记住 我说过安全更重要 事实证明 你不需要思考\N{\r原文字幕}but remember that I said that safety is more important and it turns out that you do not need to think
Dialogue: 0,0:58:22.31,0:58:24.46,译文字幕,,0,0,0,,你不需要知道时态逻辑\N{\r原文字幕}you got not need to know temporal logic
Dialogue: 0,0:58:24.47,0:58:26.32,译文字幕,,0,0,0,,为了处理安全问题\N{\r原文字幕}in order to handle safety
Dialogue: 0,0:58:26.33,0:58:34.15,译文字幕,,0,0,0,,我想你们知道TL A+比其他时序逻辑更好的原因是什么\N{\r原文字幕}and what the reason I think you know that TL A+ is better than other kinds of temporal logic
Dialogue: 0,0:58:34.10,0:58:40.45,译文字幕,,0,0,0,,为了安全起见 使用它基本上不需要时序逻辑\N{\r原文字幕}is that you need-to-know essentially no temporal logic to use it for safety
Dialogue: 0,0:58:40.96,0:58:43.24,译文字幕,,0,0,0,,如果你看看实际的规格\N{\r原文字幕}if you look at the actual specification
Dialogue: 0,0:58:43.70,0:58:46.93,译文字幕,,0,0,0,,这有具体的TLA规范\N{\r原文字幕}there is the specific the TLA specification I've noticed
Dialogue: 0,0:58:46.85,0:58:49.21,译文字幕,,0,0,0,,我已经写好了 里面有两个公式 下一个\N{\r原文字幕}I've written it it's two formulas in it and next
Dialogue: 0,0:58:48.95,0:58:54.28,译文字幕,,0,0,0,,TLA允许您将它们组合成一个单一的时序逻辑公式\N{\r原文字幕}well TLA allows you to combine them into a single temporal logic formula
Dialogue: 0,0:58:54.23,0:58:57.46,译文字幕,,0,0,0,,你知道你最终会这样做\N{\r原文字幕}which you you know you do at the end eventually
Dialogue: 0,0:58:57.74,0:59:01.99,译文字幕,,0,0,0,,但是它的伟大之处在于\N{\r原文字幕}and but the idea of the thing it makes it great is that
Dialogue: 0,0:59:01.52,0:59:08.02,译文字幕,,0,0,0,,你要写一千行的规范 999行是普通的数学\N{\r原文字幕}you'll write a thousand line specification 999 lines are going to be ordinary math
Dialogue: 0,0:59:08.00,0:59:13.12,译文字幕,,0,0,0,,初态 步进关系 然后最后一行是一个时态逻辑公式\N{\r原文字幕}initial predicate next state relation and then the last line is going to be a temporal logic formula
Dialogue: 0,0:59:13.45,0:59:14.95,译文字幕,,0,0,0,,所以好吧\N{\r原文字幕}so okay
Dialogue: 0,0:59:16.78,0:59:19.84,译文字幕,,0,0,0,,我们没有\N{\r原文字幕}well do we have no
Dialogue: 0,0:59:20.83,0:59:25.57,译文字幕,,0,0,0,,因此 我们的全体会议现在已经结束\N{\r原文字幕}so we are now at the end of our plenary session
Dialogue: 0,0:59:25.76,0:59:29.56,译文字幕,,0,0,0,,我非常感谢你 但在此之前\N{\r原文字幕}and I'd like to thank you very much but before we do that
Dialogue: 0,0:59:29.09,0:59:35.29,译文字幕,,0,0,0,,我得告诉你去哪吃\N{\r原文字幕}just to remind you all we got the buses outside to go out to the dinner tonight
Dialogue: 0,0:59:35.09,0:59:39.22,译文字幕,,0,0,0,,带走随身垃圾\N{\r原文字幕}take your bags with you there will be space there for your bags
Dialogue: 0,0:59:38.96,0:59:43.24,译文字幕,,0,0,0,,然后去哪住\N{\r原文字幕}and then we'll be going back to the hotels or coming back here and
Dialogue: 0,0:59:42.98,0:59:45.28,译文字幕,,0,0,0,,感谢Leslie\N{\r原文字幕}now thank you very much Leslie
Dialogue: 0,0:59:45.46,0:59:45.96,原文字幕,,0,0,0,,[Applause]
